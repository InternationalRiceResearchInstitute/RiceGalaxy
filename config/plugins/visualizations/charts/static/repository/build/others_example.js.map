{"version":3,"sources":["webpack:///others_example.js","webpack:///webpack/bootstrap e3622d0033a89edad914?63f1***********************","webpack:///./static/repository/visualizations/others/example/wrapper.js","webpack:///./static/repository/utilities/utils.js?825c*********************","webpack:///./static/repository/visualizations/utilities/tabular-utilities.js?ccb0******************","webpack:///./static/repository/visualizations/utilities/tabular-datasets.js?bf7b********************"],"names":["define","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","Utilities","Datasets","Backbone","View","extend","initialize","options","chart","request","dataset_id","get","dataset_groups","groups","success","colors","d3","scale","category20","error","_","each","group","group_index","svg","select","targets","height","parseInt","style","width","maxValue","max","values","d","Math","x","y","selectAll","data","enter","append","attr","abs","z","i","err","state","process","resolve","apply","undefined","clone","obj","JSON","parse","stringify","isJSON","text","test","replace","top","__utils__get__","cache_key","cache","window","console","debug","url","response","ajaxConfig","contentType","type","$","isEmptyObject","indexOf","param","dataType","ajax","done","jQuery","parseJSON","e","fail","response_text","responseText","always","complete","merge","optionsDefault","defaults","uid","__utils__uid__","Utils","buildJobDictionary","settings_string","columns_string","key","settings","attributes","settings_value","pair","RegExp","substring","length","data_columns","name","tool_id","inputs","input","src","columns","panelHelper","render","result","valid","reject","getDomains","keys","_apply","operator","value","value_sub","index","min","makeSeries","plot_data","value_index","point","key_index","column_index","push","makeCategories","column_keys","array","__data_columns","is_label","value_dict","String","mapCategories","makeUniqueCategories","with_index","categories","counter","column_def","j","makeTickFormat","precision","formatter","d3format","prefix","formatPrefix","toFixed","symbol","format","label","isNaN","addZoom","fixDomain","domain","boundary","scaleExtent","zoomed","yDomain","yScale","y_boundary","xDomain","xScale","x_boundary","redraw","unzoomed","d3zoom","translate","yAxis","xAxis","slice","behavior","zoom","nice","on","_cache","column_list","column_name","column","block_id","_block_id","_fillFromCache","Galaxy","root","data_type","provider","indeces","toString","results","Array","row","v","limit","column_data","dict"],"mappings":"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","file":"others_example.js","sourcesContent":["define(function() { return /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(4), __webpack_require__(5) ], __WEBPACK_AMD_DEFINE_RESULT__ = function( Utilities, Datasets ) {\n\t    return Backbone.View.extend({\n\t        initialize: function( options ) {\n\t            var chart = options.chart;\n\t            Datasets.request({\n\t                dataset_id      : chart.get( 'dataset_id' ),\n\t                dataset_groups  : chart.groups,\n\t                success         : function( groups ) {\n\t                    var colors = d3.scale.category20();\n\t                    var error = null;\n\t                    _.each( groups, function( group, group_index ) {\n\t                        try {\n\t                            var svg = d3.select( '#' + ( options.targets[ group_index ] || options.targets[ 0 ] ) );\n\t                            var height = parseInt( svg.style( 'height' ) );\n\t                            var width  = parseInt( svg.style( 'width' ) );\n\t                            var maxValue = d3.max( group.values, function( d ) { return Math.max( d.x, d.y ) } );\n\t                            svg.selectAll( 'bubbles' )\n\t                                .data( group.values )\n\t                                .enter().append( 'circle' )\n\t                                .attr( 'r', function( d ) { return ( Math.abs( d.z ) * 20 ) / maxValue } )\n\t                                .attr( 'cy', function( d, i ) { return height * d.y / maxValue } )\n\t                                .attr( 'cx', function( d ) { return width * d.x / maxValue } )\n\t                                .style( 'stroke', colors( group_index ) )\n\t                                .style( 'fill', 'white' );\n\t                        } catch ( err ) {\n\t                            error = err;\n\t                        }\n\t                    });\n\t                    if ( error ) {\n\t                        chart.state( 'failed', error );\n\t                    } else {\n\t                        chart.state( 'ok', 'Workshop chart has been drawn.' );\n\t                    }\n\t                    options.process.resolve();\n\t                }\n\t            });\n\t        }\n\t    });\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** Useful helper functions */\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\n\t    /** Clone */\n\t    function clone( obj ) {\n\t        return JSON.parse( JSON.stringify( obj ) || null );\n\t    };\n\t\n\t    /**\n\t     * Check if a string is a json string\n\t     * @param{String}   text - Content to be validated\n\t     */\n\t    function isJSON(text) {\n\t        return /^[\\],:{}\\s]*$/.test(text.replace(/\\\\[\"\\\\\\/bfnrtu]/g, '@').\n\t            replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']').\n\t            replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''));\n\t    };\n\t\n\t    /**\n\t     * Request handler for GET\n\t     * @param{String}   url     - Url request is made to\n\t     * @param{Function} success - Callback on success\n\t     * @param{Function} error   - Callback on error\n\t     * @param{Boolean}  cache   - Use cached data if available\n\t     */\n\t    function get (options) {\n\t        top.__utils__get__ = top.__utils__get__ || {};\n\t        var cache_key = JSON.stringify( options );\n\t        if (options.cache && top.__utils__get__[cache_key]) {\n\t            options.success && options.success(top.__utils__get__[cache_key]);\n\t            window.console.debug('utils.js::get() - Fetching from cache [' + options.url + '].');\n\t        } else {\n\t            request({\n\t                url     : options.url,\n\t                data    : options.data,\n\t                success : function(response) {\n\t                    top.__utils__get__[cache_key] = response;\n\t                    options.success && options.success(response);\n\t                },\n\t                error : function(response) {\n\t                    options.error && options.error(response);\n\t                }\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Request handler\n\t     * @param{String}   method  - Request method ['GET', 'POST', 'DELETE', 'PUT']\n\t     * @param{String}   url     - Url request is made to\n\t     * @param{Object}   data    - Data send to url\n\t     * @param{Function} success - Callback on success\n\t     * @param{Function} error   - Callback on error\n\t     */\n\t    function request (options) {\n\t        var ajaxConfig = {\n\t            contentType : 'application/json',\n\t            type        : options.type || 'GET',\n\t            data        : options.data || {},\n\t            url         : options.url\n\t        }\n\t        if ( ajaxConfig.type == 'GET' || ajaxConfig.type == 'DELETE' ) {\n\t            if ( !$.isEmptyObject(ajaxConfig.data) ) {\n\t                ajaxConfig.url += ajaxConfig.url.indexOf('?') == -1 ? '?' : '&';\n\t                ajaxConfig.url += $.param(ajaxConfig.data, true);\n\t            }\n\t            ajaxConfig.data = null;\n\t        } else {\n\t            ajaxConfig.dataType = 'json';\n\t            ajaxConfig.url      = ajaxConfig.url;\n\t            ajaxConfig.data     = JSON.stringify( ajaxConfig.data );\n\t        }\n\t        $.ajax( ajaxConfig ).done( function( response ) {\n\t            if ( typeof response === 'string' && isJSON( response ) ) {\n\t                try {\n\t                    response = response.replace( 'Infinity,', '\"Infinity\",' );\n\t                    response = jQuery.parseJSON( response );\n\t                } catch ( e ) {\n\t                    console.debug( e );\n\t                }\n\t            }\n\t            options.success && options.success( response );\n\t        }).fail( function( response ) {\n\t            var response_text = null;\n\t            try {\n\t                response_text = jQuery.parseJSON( response.responseText );\n\t            } catch (e) {\n\t                response_text = response.responseText;\n\t            }\n\t            options.error && options.error( response_text, response );\n\t        }).always( function() {\n\t            options.complete && options.complete();\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Safely merge to dictionaries\n\t     * @param{Object}   options         - Target dictionary\n\t     * @param{Object}   optionsDefault  - Source dictionary\n\t     */\n\t    function merge (options, optionsDefault) {\n\t        if (options) {\n\t            return _.defaults(options, optionsDefault);\n\t        } else {\n\t            return optionsDefault;\n\t        }\n\t    };\n\t\n\t    /** Create a unique id */\n\t    function uid(){\n\t        top.__utils__uid__ = top.__utils__uid__ || 0;\n\t        return 'uid-' + top.__utils__uid__++;\n\t    };\n\t\n\t    return {\n\t        get     : get,\n\t        merge   : merge,\n\t        uid     : uid,\n\t        request : request,\n\t        clone   : clone,\n\t        isJSON  : isJSON\n\t    };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n/* 2 */,\n/* 3 */,\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1), __webpack_require__(5) ], __WEBPACK_AMD_DEFINE_RESULT__ = function( Utils, Datasets ) {\n\t    /** build job dictionary */\n\t    function buildJobDictionary( chart, module ) {\n\t        var settings_string = '';\n\t        var columns_string = '';\n\t        var group_index = 0;\n\t        for ( key in chart.settings.attributes ) {\n\t            var settings_value = chart.settings.get( key );\n\t            _.each( [ [ ' ', '&#32;' ], [ ',', '&#44;' ], [ ':', '&#58;' ] ], function( pair ) {\n\t                settings_value = settings_value.replace( new RegExp( pair[ 0 ], 'g' ), pair[ 1 ] );\n\t            });\n\t            settings_string += key + ':' + settings_value + ', ';\n\t        };\n\t        settings_string = settings_string.substring( 0, settings_string.length - 2 )\n\t        chart.groups.each( function( group ) {\n\t            group_index++;\n\t            _.each( group.get( '__data_columns' ), function( data_columns, name ) {\n\t                columns_string += name + '_' + group_index + ':' + ( parseInt( group.get( name ) ) + 1 ) + ', ';\n\t            });\n\t        });\n\t        columns_string = columns_string.substring( 0, columns_string.length - 2 );\n\t        return {\n\t                    'tool_id'       : 'charts',\n\t                    'inputs'        : {\n\t                        'input'     : {\n\t                            'id'    : chart.get( 'dataset_id' ),\n\t                            'src'   : 'hda'\n\t                        },\n\t                        'module'    : module,\n\t                        'columns'   : columns_string,\n\t                        'settings'  : settings_string\n\t                    }\n\t                }\n\t    };\n\t\n\t    /** Assists in assigning the viewport panels */\n\t    function panelHelper( options ) {\n\t        var self = this;\n\t        var process             = options.process;\n\t        var chart               = options.chart;\n\t        var render              = options.render;\n\t        var targets             = options.targets;\n\t        var dataset_id          = options.dataset_id || options.chart.get( 'dataset_id' );\n\t        var dataset_groups      = options.dataset_groups || options.chart.groups;\n\t        Datasets.request({\n\t            chart           : chart,\n\t            dataset_id      : dataset_id,\n\t            dataset_groups  : dataset_groups,\n\t            success         : function( result ) {\n\t                try {\n\t                    if ( targets.length == result.length ) {\n\t                        var valid = true;\n\t                        for ( var group_index in result ) {\n\t                            var group = result[ group_index ];\n\t                            if ( !render( targets[ group_index ], [ group ] ) ) {\n\t                                valid = false;\n\t                                break;\n\t                            }\n\t                        }\n\t                        if ( valid ) {\n\t                            chart.state( 'ok', 'Multi-panel chart drawn.' );\n\t                        }\n\t                    } else if ( targets.length == 1 ) {\n\t                        if ( render( targets[ 0 ], result ) ) {\n\t                            chart.state( 'ok', 'Chart drawn.' );\n\t                        }\n\t                    } else {\n\t                        chart.state( 'failed', 'Invalid panel count.' );\n\t                    }\n\t                    process.resolve();\n\t                } catch ( err ) {\n\t                    console.debug( 'FAILED: tabular-utilities::panelHelper() - ' + err );\n\t                    chart.state( 'failed', err );\n\t                    process.reject();\n\t                }\n\t            }\n\t        });\n\t    };\n\t\n\t    /** Get domain boundaries value */\n\t    function getDomains( groups, keys ) {\n\t        function _apply( operator, key ) {\n\t            var value = undefined;\n\t            for ( var group_index in groups ) {\n\t                var value_sub = d3[ operator ]( groups[ group_index ].values, function( d ) { return d[ key ] } );\n\t                value = value === undefined ? value_sub : Math[ operator ]( value, value_sub );\n\t            }\n\t            return value;\n\t        };\n\t        var result = {};\n\t        for( var index in keys ) {\n\t            var key = keys[ index ];\n\t            result[ key ] = {\n\t                min : _apply( 'min', key ),\n\t                max : _apply( 'max', key ),\n\t            };\n\t           \n\t        }\n\t        return result;\n\t    };\n\t\n\t    /** Default series maker */\n\t    function makeSeries( groups, keys ) {\n\t        var plot_data = [];\n\t        for ( var group_index in groups ) {\n\t            var group = groups[ group_index ];\n\t            var data = [];\n\t            for ( var value_index in group.values ) {\n\t                var point = [];\n\t                if ( keys ) {\n\t                    for ( var key_index in keys ) {\n\t                        var column_index = keys[ key_index ];\n\t                        point.push( group.values[ value_index ][ column_index ] );\n\t                    }\n\t                } else {\n\t                    for ( var column_index in group.values[ value_index ] ) {\n\t                        point.push( group.values[ value_index ][ column_index ] );\n\t                    }\n\t                }\n\t                data.push( point );\n\t            }\n\t            plot_data.push( data );\n\t        }\n\t        return plot_data;\n\t    };\n\t\n\t    /** Default category maker */\n\t    function makeCategories( groups, column_keys ) {\n\t        var array = {};\n\t        var data_columns = groups[ 0 ].__data_columns;\n\t        _.each( column_keys, function( key ) {\n\t            if ( data_columns[ key ].is_label ) {\n\t                array[ key ] = [];\n\t            }\n\t        });\n\t        if ( groups && groups[ 0 ] ) {\n\t            _.each( groups[ 0 ].values, function( value_dict ) {\n\t                for ( var key in array ) {\n\t                    array[ key ].push( String( value_dict[ key ] ) );\n\t                }\n\t            });\n\t        }\n\t        mapCategories( array, groups );\n\t        return { array : array }\n\t    };\n\t\n\t    /** Apply default mapping index all values contained in label columns (for all groups) */\n\t    function mapCategories( array, groups ) {\n\t        _.each( groups, function( group ) {\n\t            _.each( group.values, function( value_dict, i ) {\n\t                for ( var key in array ) {\n\t                    value_dict[ key ] = parseInt( i )\n\t                }\n\t            });\n\t        });\n\t    };\n\t\n\t    /** Category make for unique category labels */\n\t    function makeUniqueCategories( groups, with_index ) {\n\t        var categories  = {};\n\t        var array       = {};\n\t        var counter     = {};\n\t        var data_columns = groups[ 0 ].__data_columns;\n\t        _.each( data_columns, function( column_def, key ) {\n\t            if ( column_def.is_label ) {\n\t                categories[ key ] = {};\n\t                array[ key ]      = [];\n\t                counter[ key ]    = 0;\n\t            }\n\t        });\n\t        // index all values contained in label columns (for all groups)\n\t        for ( var i in groups ) {\n\t            var group = groups[ i ];\n\t            for ( var j in group.values ) {\n\t                var value_dict = group.values[ j ];\n\t                for ( var key in categories ) {\n\t                    var value = String( value_dict[ key ] );\n\t                    if ( categories[ key ][ value ] === undefined ) {\n\t                        categories[ key ][ value ] = counter[ key ];\n\t                        array[ key ].push( with_index ? [counter[key], value] : value );\n\t                        counter[ key ]++;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        // convert group values into category indeces\n\t        for ( var i in groups ) {\n\t            var group = groups[ i ];\n\t            for ( var j in group.values ) {\n\t                var value_dict = group.values[ j ];\n\t                for ( var key in categories ) {\n\t                    var value = String( value_dict[ key ] );\n\t                    value_dict[ key ] = categories[ key ][ value ];\n\t                }\n\t            }\n\t        }\n\t        return {\n\t            categories  : categories,\n\t            array       : array,\n\t            counter     : counter\n\t        }\n\t    };\n\t\n\t    /** Make axis */\n\t    function makeTickFormat ( options ) {\n\t        var type        = options.type;\n\t        var precision   = options.precision;\n\t        var categories  = options.categories;\n\t        var formatter   = options.formatter;\n\t        if ( type == 'hide' ) {\n\t            formatter( function() { return '' } );\n\t        } else if ( type == 'auto' ) {\n\t            if ( categories ) {\n\t                formatter( function( value ) { return categories[ value ] || '' } );\n\t            }\n\t        } else {\n\t            var d3format = function( d ) {\n\t                switch ( type ) {\n\t                    case 's':\n\t                        var prefix = d3.formatPrefix( d );\n\t                        return prefix.scale( d ).toFixed() + prefix.symbol;\n\t                    default :\n\t                        return d3.format( '.' + precision + type )( d );\n\t                }\n\t            };\n\t            if ( categories ) {\n\t                formatter( function( value ) {\n\t                    var label = categories[ value ];\n\t                    if ( label ) {\n\t                        if ( isNaN( label ) ) {\n\t                            return label;\n\t                        } else {\n\t                            try {\n\t                                return d3format( label );\n\t                            } catch ( err ) {\n\t                                return label;\n\t                            }\n\t                        }\n\t                    } else {\n\t                        return '';\n\t                    }\n\t                });\n\t            } else {\n\t                formatter( function( value ) { return d3format( value ) } );\n\t            }\n\t        }\n\t    };\n\t\n\t    /** Add zoom handler */\n\t    function addZoom( options ) {\n\t        var scaleExtent = 100;\n\t        var yAxis       = options.yAxis;\n\t        var xAxis       = options.xAxis;\n\t        var xDomain     = options.xDomain || xAxis.scale().domain;\n\t        var yDomain     = options.yDomain || yAxis.scale().domain;\n\t        var redraw      = options.redraw;\n\t        var svg         = options.svg;\n\t        var xScale      = xAxis.scale();\n\t        var yScale      = yAxis.scale();\n\t        var x_boundary  = xScale.domain().slice();\n\t        var y_boundary  = yScale.domain().slice();\n\t        var d3zoom      = d3.behavior.zoom();\n\t        xScale.nice();\n\t        yScale.nice();\n\t        function fixDomain( domain, boundary ) {\n\t            domain[ 0 ] = Math.min( Math.max( domain[ 0 ], boundary[ 0 ] ), boundary[ 1 ] - boundary[ 1 ]/scaleExtent );\n\t            domain[ 1 ] = Math.max( boundary[ 0 ] + boundary[ 1 ] / scaleExtent, Math.min( domain[ 1 ], boundary[ 1 ] ) );\n\t            return domain;\n\t        };\n\t        function zoomed() {\n\t            yDomain( fixDomain( yScale.domain(), y_boundary ) );\n\t            xDomain( fixDomain( xScale.domain(), x_boundary ) );\n\t            redraw();\n\t        };\n\t        function unzoomed() {\n\t            xDomain( x_boundary );\n\t            yDomain( y_boundary );\n\t            redraw();\n\t            d3zoom.scale( 1 );\n\t            d3zoom.translate( [ 0 , 0 ] );\n\t        };\n\t        d3zoom.x( xScale )\n\t              .y( yScale )\n\t              .scaleExtent( [ 1, scaleExtent ] )\n\t              .on( 'zoom', zoomed );\n\t        svg.call( d3zoom ).on( 'dblclick.zoom', unzoomed );\n\t        return d3zoom;\n\t    };\n\t\n\t    return {\n\t        buildJobDictionary      : buildJobDictionary,\n\t        panelHelper             : panelHelper,\n\t        makeCategories          : makeCategories,\n\t        makeUniqueCategories    : makeUniqueCategories,\n\t        makeSeries              : makeSeries,\n\t        getDomains              : getDomains,\n\t        mapCategories           : mapCategories,\n\t        makeTickFormat          : makeTickFormat,\n\t        addZoom                 : addZoom\n\t    }\n\t\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** This class handles, formats and caches datasets. */\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1) ], __WEBPACK_AMD_DEFINE_RESULT__ = function( Utils ) {\n\t    /** Fills request dictionary with data from cache/response */\n\t    var _cache = {};\n\t    var request = function( options ) {\n\t        var groups      = options.dataset_groups;\n\t        var dataset_id  = options.dataset_id;\n\t        // identify columns needed to fulfill request\n\t        var column_list = [];\n\t        groups.each( function( group ) {\n\t            _.each( group.get( '__data_columns' ), function( column_def, column_name ) {\n\t                var column = group.get( column_name );\n\t                var block_id = _block_id( dataset_id, column );\n\t                if ( column_list.indexOf( column ) === -1 && !_cache[ block_id ] && column != 'auto' && column != 'zero' && column !== undefined ) {\n\t                    column_list.push( column );\n\t                }\n\t            });\n\t        });\n\t        if ( column_list.length == 0 ) {\n\t            _fillFromCache( options );\n\t            return;\n\t        }\n\t        // Fetch data columns into dataset object\n\t        Utils.get({\n\t            url     : Galaxy.root + 'api/datasets/' + dataset_id,\n\t            data    : {\n\t                data_type   : 'raw_data',\n\t                provider    : 'dataset-column',\n\t                indeces     : column_list.toString()\n\t            },\n\t            success : function( response ) {\n\t                var results = new Array( column_list.length );\n\t                for ( var i = 0; i < results.length; i++ ) {\n\t                    results[ i ] = [];\n\t                }\n\t                for ( var i in response.data ) {\n\t                    var row = response.data[ i ];\n\t                    for ( var j in row ) {\n\t                        var v = row[ j ];\n\t                        if ( v !== undefined && v != 2147483647 ) {\n\t                            results[ j ].push( v );\n\t                        }\n\t                    }\n\t                }\n\t                console.debug( 'tabular-datasets::_fetch() - Fetching complete.' );\n\t                for ( var i in results ) {\n\t                    var column = column_list[ i ];\n\t                    var block_id = _block_id( dataset_id, column );\n\t                    _cache[ block_id ] = results[ i ];\n\t                }\n\t                _fillFromCache( options );\n\t            }\n\t        });\n\t    };\n\t\n\t    /** Fill data from cache */\n\t    var _fillFromCache = function( options ) {\n\t        var groups      = options.dataset_groups;\n\t        var dataset_id  = options.dataset_id;\n\t        console.debug( 'tabular-datasets::_fillFromCache() - Filling request from cache.' );\n\t        var limit = 0;\n\t        groups.each( function( group ) {\n\t            _.each( group.get( '__data_columns' ), function( column_def, column_name ) {\n\t                var column = group.get( column_name );\n\t                var block_id = _block_id( dataset_id, column );\n\t                var column_data = _cache[ block_id ];\n\t                if ( column_data ) {\n\t                    limit = Math.max( limit, column_data.length );\n\t                }\n\t            });\n\t        });\n\t        if ( limit == 0 ) {\n\t            console.debug( 'tabular-datasets::_fillFromCache() - No data available.' );\n\t        }\n\t        var results = [];\n\t        groups.each( function( group, group_index ) {\n\t            var dict = Utils.merge( { key: ( group_index ) + ':' + group.get( 'key' ), values: [] }, group.attributes );\n\t            for ( var j = 0; j < limit; j++ ) {\n\t                dict.values[ j ] = { x : parseInt( j ) };\n\t            }\n\t            results.push( dict );\n\t        });\n\t        groups.each( function( group, group_index ) {\n\t            var values = results[ group_index ].values;\n\t            _.each( group.get( '__data_columns' ), function( column_def, column_name ) {\n\t                var column = group.get( column_name );\n\t                switch ( column ) {\n\t                    case 'auto':\n\t                        for ( var j = 0; j < limit; j++ ) {\n\t                            values[ j ][ column_name ] = parseInt( j );\n\t                        }\n\t                        break;\n\t                    case 'zero':\n\t                        for ( var j = 0; j < limit; j++ ) {\n\t                            values[ j ][ column_name ] = 0;\n\t                        }\n\t                        break;\n\t                    default:\n\t                        var block_id = _block_id( dataset_id, column );\n\t                        var column_data = _cache[ block_id ];\n\t                        for ( var j = 0; j < limit; j++ ) {\n\t                            var value = values[ j ];\n\t                            var v = column_data[ j ];\n\t                            if ( isNaN( v ) && !column_def.is_label ) {\n\t                                v = 0;\n\t                            }\n\t                            value[ column_name ] = v;\n\t                        }\n\t                }\n\t            });\n\t        });\n\t        options.success( results );\n\t    };\n\t\n\t    /** Get block id */\n\t    var _block_id = function ( dataset_id, column ) {\n\t        return dataset_id + '_' + '_' + column;\n\t    };\n\t\n\t    return { request: request };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ }\n/******/ ])});;\n\n\n/** WEBPACK FOOTER **\n ** others_example.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e3622d0033a89edad914\n **/","define( [ 'visualizations/utilities/tabular-utilities', 'visualizations/utilities/tabular-datasets' ], function( Utilities, Datasets ) {\n    return Backbone.View.extend({\n        initialize: function( options ) {\n            var chart = options.chart;\n            Datasets.request({\n                dataset_id      : chart.get( 'dataset_id' ),\n                dataset_groups  : chart.groups,\n                success         : function( groups ) {\n                    var colors = d3.scale.category20();\n                    var error = null;\n                    _.each( groups, function( group, group_index ) {\n                        try {\n                            var svg = d3.select( '#' + ( options.targets[ group_index ] || options.targets[ 0 ] ) );\n                            var height = parseInt( svg.style( 'height' ) );\n                            var width  = parseInt( svg.style( 'width' ) );\n                            var maxValue = d3.max( group.values, function( d ) { return Math.max( d.x, d.y ) } );\n                            svg.selectAll( 'bubbles' )\n                                .data( group.values )\n                                .enter().append( 'circle' )\n                                .attr( 'r', function( d ) { return ( Math.abs( d.z ) * 20 ) / maxValue } )\n                                .attr( 'cy', function( d, i ) { return height * d.y / maxValue } )\n                                .attr( 'cx', function( d ) { return width * d.x / maxValue } )\n                                .style( 'stroke', colors( group_index ) )\n                                .style( 'fill', 'white' );\n                        } catch ( err ) {\n                            error = err;\n                        }\n                    });\n                    if ( error ) {\n                        chart.state( 'failed', error );\n                    } else {\n                        chart.state( 'ok', 'Workshop chart has been drawn.' );\n                    }\n                    options.process.resolve();\n                }\n            });\n        }\n    });\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./static/repository/visualizations/others/example/wrapper.js\n ** module id = 0\n ** module chunks = 24\n **/","/** Useful helper functions */\ndefine( [], function() {\n\n    /** Clone */\n    function clone( obj ) {\n        return JSON.parse( JSON.stringify( obj ) || null );\n    };\n\n    /**\n     * Check if a string is a json string\n     * @param{String}   text - Content to be validated\n     */\n    function isJSON(text) {\n        return /^[\\],:{}\\s]*$/.test(text.replace(/\\\\[\"\\\\\\/bfnrtu]/g, '@').\n            replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']').\n            replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''));\n    };\n\n    /**\n     * Request handler for GET\n     * @param{String}   url     - Url request is made to\n     * @param{Function} success - Callback on success\n     * @param{Function} error   - Callback on error\n     * @param{Boolean}  cache   - Use cached data if available\n     */\n    function get (options) {\n        top.__utils__get__ = top.__utils__get__ || {};\n        var cache_key = JSON.stringify( options );\n        if (options.cache && top.__utils__get__[cache_key]) {\n            options.success && options.success(top.__utils__get__[cache_key]);\n            window.console.debug('utils.js::get() - Fetching from cache [' + options.url + '].');\n        } else {\n            request({\n                url     : options.url,\n                data    : options.data,\n                success : function(response) {\n                    top.__utils__get__[cache_key] = response;\n                    options.success && options.success(response);\n                },\n                error : function(response) {\n                    options.error && options.error(response);\n                }\n            });\n        }\n    };\n\n    /**\n     * Request handler\n     * @param{String}   method  - Request method ['GET', 'POST', 'DELETE', 'PUT']\n     * @param{String}   url     - Url request is made to\n     * @param{Object}   data    - Data send to url\n     * @param{Function} success - Callback on success\n     * @param{Function} error   - Callback on error\n     */\n    function request (options) {\n        var ajaxConfig = {\n            contentType : 'application/json',\n            type        : options.type || 'GET',\n            data        : options.data || {},\n            url         : options.url\n        }\n        if ( ajaxConfig.type == 'GET' || ajaxConfig.type == 'DELETE' ) {\n            if ( !$.isEmptyObject(ajaxConfig.data) ) {\n                ajaxConfig.url += ajaxConfig.url.indexOf('?') == -1 ? '?' : '&';\n                ajaxConfig.url += $.param(ajaxConfig.data, true);\n            }\n            ajaxConfig.data = null;\n        } else {\n            ajaxConfig.dataType = 'json';\n            ajaxConfig.url      = ajaxConfig.url;\n            ajaxConfig.data     = JSON.stringify( ajaxConfig.data );\n        }\n        $.ajax( ajaxConfig ).done( function( response ) {\n            if ( typeof response === 'string' && isJSON( response ) ) {\n                try {\n                    response = response.replace( 'Infinity,', '\"Infinity\",' );\n                    response = jQuery.parseJSON( response );\n                } catch ( e ) {\n                    console.debug( e );\n                }\n            }\n            options.success && options.success( response );\n        }).fail( function( response ) {\n            var response_text = null;\n            try {\n                response_text = jQuery.parseJSON( response.responseText );\n            } catch (e) {\n                response_text = response.responseText;\n            }\n            options.error && options.error( response_text, response );\n        }).always( function() {\n            options.complete && options.complete();\n        });\n    };\n\n    /**\n     * Safely merge to dictionaries\n     * @param{Object}   options         - Target dictionary\n     * @param{Object}   optionsDefault  - Source dictionary\n     */\n    function merge (options, optionsDefault) {\n        if (options) {\n            return _.defaults(options, optionsDefault);\n        } else {\n            return optionsDefault;\n        }\n    };\n\n    /** Create a unique id */\n    function uid(){\n        top.__utils__uid__ = top.__utils__uid__ || 0;\n        return 'uid-' + top.__utils__uid__++;\n    };\n\n    return {\n        get     : get,\n        merge   : merge,\n        uid     : uid,\n        request : request,\n        clone   : clone,\n        isJSON  : isJSON\n    };\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./static/repository/utilities/utils.js\n ** module id = 1\n ** module chunks = 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n **/","define( [ 'utilities/utils', 'visualizations/utilities/tabular-datasets' ], function( Utils, Datasets ) {\n    /** build job dictionary */\n    function buildJobDictionary( chart, module ) {\n        var settings_string = '';\n        var columns_string = '';\n        var group_index = 0;\n        for ( key in chart.settings.attributes ) {\n            var settings_value = chart.settings.get( key );\n            _.each( [ [ ' ', '&#32;' ], [ ',', '&#44;' ], [ ':', '&#58;' ] ], function( pair ) {\n                settings_value = settings_value.replace( new RegExp( pair[ 0 ], 'g' ), pair[ 1 ] );\n            });\n            settings_string += key + ':' + settings_value + ', ';\n        };\n        settings_string = settings_string.substring( 0, settings_string.length - 2 )\n        chart.groups.each( function( group ) {\n            group_index++;\n            _.each( group.get( '__data_columns' ), function( data_columns, name ) {\n                columns_string += name + '_' + group_index + ':' + ( parseInt( group.get( name ) ) + 1 ) + ', ';\n            });\n        });\n        columns_string = columns_string.substring( 0, columns_string.length - 2 );\n        return {\n                    'tool_id'       : 'charts',\n                    'inputs'        : {\n                        'input'     : {\n                            'id'    : chart.get( 'dataset_id' ),\n                            'src'   : 'hda'\n                        },\n                        'module'    : module,\n                        'columns'   : columns_string,\n                        'settings'  : settings_string\n                    }\n                }\n    };\n\n    /** Assists in assigning the viewport panels */\n    function panelHelper( options ) {\n        var self = this;\n        var process             = options.process;\n        var chart               = options.chart;\n        var render              = options.render;\n        var targets             = options.targets;\n        var dataset_id          = options.dataset_id || options.chart.get( 'dataset_id' );\n        var dataset_groups      = options.dataset_groups || options.chart.groups;\n        Datasets.request({\n            chart           : chart,\n            dataset_id      : dataset_id,\n            dataset_groups  : dataset_groups,\n            success         : function( result ) {\n                try {\n                    if ( targets.length == result.length ) {\n                        var valid = true;\n                        for ( var group_index in result ) {\n                            var group = result[ group_index ];\n                            if ( !render( targets[ group_index ], [ group ] ) ) {\n                                valid = false;\n                                break;\n                            }\n                        }\n                        if ( valid ) {\n                            chart.state( 'ok', 'Multi-panel chart drawn.' );\n                        }\n                    } else if ( targets.length == 1 ) {\n                        if ( render( targets[ 0 ], result ) ) {\n                            chart.state( 'ok', 'Chart drawn.' );\n                        }\n                    } else {\n                        chart.state( 'failed', 'Invalid panel count.' );\n                    }\n                    process.resolve();\n                } catch ( err ) {\n                    console.debug( 'FAILED: tabular-utilities::panelHelper() - ' + err );\n                    chart.state( 'failed', err );\n                    process.reject();\n                }\n            }\n        });\n    };\n\n    /** Get domain boundaries value */\n    function getDomains( groups, keys ) {\n        function _apply( operator, key ) {\n            var value = undefined;\n            for ( var group_index in groups ) {\n                var value_sub = d3[ operator ]( groups[ group_index ].values, function( d ) { return d[ key ] } );\n                value = value === undefined ? value_sub : Math[ operator ]( value, value_sub );\n            }\n            return value;\n        };\n        var result = {};\n        for( var index in keys ) {\n            var key = keys[ index ];\n            result[ key ] = {\n                min : _apply( 'min', key ),\n                max : _apply( 'max', key ),\n            };\n           \n        }\n        return result;\n    };\n\n    /** Default series maker */\n    function makeSeries( groups, keys ) {\n        var plot_data = [];\n        for ( var group_index in groups ) {\n            var group = groups[ group_index ];\n            var data = [];\n            for ( var value_index in group.values ) {\n                var point = [];\n                if ( keys ) {\n                    for ( var key_index in keys ) {\n                        var column_index = keys[ key_index ];\n                        point.push( group.values[ value_index ][ column_index ] );\n                    }\n                } else {\n                    for ( var column_index in group.values[ value_index ] ) {\n                        point.push( group.values[ value_index ][ column_index ] );\n                    }\n                }\n                data.push( point );\n            }\n            plot_data.push( data );\n        }\n        return plot_data;\n    };\n\n    /** Default category maker */\n    function makeCategories( groups, column_keys ) {\n        var array = {};\n        var data_columns = groups[ 0 ].__data_columns;\n        _.each( column_keys, function( key ) {\n            if ( data_columns[ key ].is_label ) {\n                array[ key ] = [];\n            }\n        });\n        if ( groups && groups[ 0 ] ) {\n            _.each( groups[ 0 ].values, function( value_dict ) {\n                for ( var key in array ) {\n                    array[ key ].push( String( value_dict[ key ] ) );\n                }\n            });\n        }\n        mapCategories( array, groups );\n        return { array : array }\n    };\n\n    /** Apply default mapping index all values contained in label columns (for all groups) */\n    function mapCategories( array, groups ) {\n        _.each( groups, function( group ) {\n            _.each( group.values, function( value_dict, i ) {\n                for ( var key in array ) {\n                    value_dict[ key ] = parseInt( i )\n                }\n            });\n        });\n    };\n\n    /** Category make for unique category labels */\n    function makeUniqueCategories( groups, with_index ) {\n        var categories  = {};\n        var array       = {};\n        var counter     = {};\n        var data_columns = groups[ 0 ].__data_columns;\n        _.each( data_columns, function( column_def, key ) {\n            if ( column_def.is_label ) {\n                categories[ key ] = {};\n                array[ key ]      = [];\n                counter[ key ]    = 0;\n            }\n        });\n        // index all values contained in label columns (for all groups)\n        for ( var i in groups ) {\n            var group = groups[ i ];\n            for ( var j in group.values ) {\n                var value_dict = group.values[ j ];\n                for ( var key in categories ) {\n                    var value = String( value_dict[ key ] );\n                    if ( categories[ key ][ value ] === undefined ) {\n                        categories[ key ][ value ] = counter[ key ];\n                        array[ key ].push( with_index ? [counter[key], value] : value );\n                        counter[ key ]++;\n                    }\n                }\n            }\n        }\n        // convert group values into category indeces\n        for ( var i in groups ) {\n            var group = groups[ i ];\n            for ( var j in group.values ) {\n                var value_dict = group.values[ j ];\n                for ( var key in categories ) {\n                    var value = String( value_dict[ key ] );\n                    value_dict[ key ] = categories[ key ][ value ];\n                }\n            }\n        }\n        return {\n            categories  : categories,\n            array       : array,\n            counter     : counter\n        }\n    };\n\n    /** Make axis */\n    function makeTickFormat ( options ) {\n        var type        = options.type;\n        var precision   = options.precision;\n        var categories  = options.categories;\n        var formatter   = options.formatter;\n        if ( type == 'hide' ) {\n            formatter( function() { return '' } );\n        } else if ( type == 'auto' ) {\n            if ( categories ) {\n                formatter( function( value ) { return categories[ value ] || '' } );\n            }\n        } else {\n            var d3format = function( d ) {\n                switch ( type ) {\n                    case 's':\n                        var prefix = d3.formatPrefix( d );\n                        return prefix.scale( d ).toFixed() + prefix.symbol;\n                    default :\n                        return d3.format( '.' + precision + type )( d );\n                }\n            };\n            if ( categories ) {\n                formatter( function( value ) {\n                    var label = categories[ value ];\n                    if ( label ) {\n                        if ( isNaN( label ) ) {\n                            return label;\n                        } else {\n                            try {\n                                return d3format( label );\n                            } catch ( err ) {\n                                return label;\n                            }\n                        }\n                    } else {\n                        return '';\n                    }\n                });\n            } else {\n                formatter( function( value ) { return d3format( value ) } );\n            }\n        }\n    };\n\n    /** Add zoom handler */\n    function addZoom( options ) {\n        var scaleExtent = 100;\n        var yAxis       = options.yAxis;\n        var xAxis       = options.xAxis;\n        var xDomain     = options.xDomain || xAxis.scale().domain;\n        var yDomain     = options.yDomain || yAxis.scale().domain;\n        var redraw      = options.redraw;\n        var svg         = options.svg;\n        var xScale      = xAxis.scale();\n        var yScale      = yAxis.scale();\n        var x_boundary  = xScale.domain().slice();\n        var y_boundary  = yScale.domain().slice();\n        var d3zoom      = d3.behavior.zoom();\n        xScale.nice();\n        yScale.nice();\n        function fixDomain( domain, boundary ) {\n            domain[ 0 ] = Math.min( Math.max( domain[ 0 ], boundary[ 0 ] ), boundary[ 1 ] - boundary[ 1 ]/scaleExtent );\n            domain[ 1 ] = Math.max( boundary[ 0 ] + boundary[ 1 ] / scaleExtent, Math.min( domain[ 1 ], boundary[ 1 ] ) );\n            return domain;\n        };\n        function zoomed() {\n            yDomain( fixDomain( yScale.domain(), y_boundary ) );\n            xDomain( fixDomain( xScale.domain(), x_boundary ) );\n            redraw();\n        };\n        function unzoomed() {\n            xDomain( x_boundary );\n            yDomain( y_boundary );\n            redraw();\n            d3zoom.scale( 1 );\n            d3zoom.translate( [ 0 , 0 ] );\n        };\n        d3zoom.x( xScale )\n              .y( yScale )\n              .scaleExtent( [ 1, scaleExtent ] )\n              .on( 'zoom', zoomed );\n        svg.call( d3zoom ).on( 'dblclick.zoom', unzoomed );\n        return d3zoom;\n    };\n\n    return {\n        buildJobDictionary      : buildJobDictionary,\n        panelHelper             : panelHelper,\n        makeCategories          : makeCategories,\n        makeUniqueCategories    : makeUniqueCategories,\n        makeSeries              : makeSeries,\n        getDomains              : getDomains,\n        mapCategories           : mapCategories,\n        makeTickFormat          : makeTickFormat,\n        addZoom                 : addZoom\n    }\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./static/repository/visualizations/utilities/tabular-utilities.js\n ** module id = 4\n ** module chunks = 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 21 22 24\n **/","/** This class handles, formats and caches datasets. */\ndefine( [ 'utilities/utils' ], function( Utils ) {\n    /** Fills request dictionary with data from cache/response */\n    var _cache = {};\n    var request = function( options ) {\n        var groups      = options.dataset_groups;\n        var dataset_id  = options.dataset_id;\n        // identify columns needed to fulfill request\n        var column_list = [];\n        groups.each( function( group ) {\n            _.each( group.get( '__data_columns' ), function( column_def, column_name ) {\n                var column = group.get( column_name );\n                var block_id = _block_id( dataset_id, column );\n                if ( column_list.indexOf( column ) === -1 && !_cache[ block_id ] && column != 'auto' && column != 'zero' && column !== undefined ) {\n                    column_list.push( column );\n                }\n            });\n        });\n        if ( column_list.length == 0 ) {\n            _fillFromCache( options );\n            return;\n        }\n        // Fetch data columns into dataset object\n        Utils.get({\n            url     : Galaxy.root + 'api/datasets/' + dataset_id,\n            data    : {\n                data_type   : 'raw_data',\n                provider    : 'dataset-column',\n                indeces     : column_list.toString()\n            },\n            success : function( response ) {\n                var results = new Array( column_list.length );\n                for ( var i = 0; i < results.length; i++ ) {\n                    results[ i ] = [];\n                }\n                for ( var i in response.data ) {\n                    var row = response.data[ i ];\n                    for ( var j in row ) {\n                        var v = row[ j ];\n                        if ( v !== undefined && v != 2147483647 ) {\n                            results[ j ].push( v );\n                        }\n                    }\n                }\n                console.debug( 'tabular-datasets::_fetch() - Fetching complete.' );\n                for ( var i in results ) {\n                    var column = column_list[ i ];\n                    var block_id = _block_id( dataset_id, column );\n                    _cache[ block_id ] = results[ i ];\n                }\n                _fillFromCache( options );\n            }\n        });\n    };\n\n    /** Fill data from cache */\n    var _fillFromCache = function( options ) {\n        var groups      = options.dataset_groups;\n        var dataset_id  = options.dataset_id;\n        console.debug( 'tabular-datasets::_fillFromCache() - Filling request from cache.' );\n        var limit = 0;\n        groups.each( function( group ) {\n            _.each( group.get( '__data_columns' ), function( column_def, column_name ) {\n                var column = group.get( column_name );\n                var block_id = _block_id( dataset_id, column );\n                var column_data = _cache[ block_id ];\n                if ( column_data ) {\n                    limit = Math.max( limit, column_data.length );\n                }\n            });\n        });\n        if ( limit == 0 ) {\n            console.debug( 'tabular-datasets::_fillFromCache() - No data available.' );\n        }\n        var results = [];\n        groups.each( function( group, group_index ) {\n            var dict = Utils.merge( { key: ( group_index ) + ':' + group.get( 'key' ), values: [] }, group.attributes );\n            for ( var j = 0; j < limit; j++ ) {\n                dict.values[ j ] = { x : parseInt( j ) };\n            }\n            results.push( dict );\n        });\n        groups.each( function( group, group_index ) {\n            var values = results[ group_index ].values;\n            _.each( group.get( '__data_columns' ), function( column_def, column_name ) {\n                var column = group.get( column_name );\n                switch ( column ) {\n                    case 'auto':\n                        for ( var j = 0; j < limit; j++ ) {\n                            values[ j ][ column_name ] = parseInt( j );\n                        }\n                        break;\n                    case 'zero':\n                        for ( var j = 0; j < limit; j++ ) {\n                            values[ j ][ column_name ] = 0;\n                        }\n                        break;\n                    default:\n                        var block_id = _block_id( dataset_id, column );\n                        var column_data = _cache[ block_id ];\n                        for ( var j = 0; j < limit; j++ ) {\n                            var value = values[ j ];\n                            var v = column_data[ j ];\n                            if ( isNaN( v ) && !column_def.is_label ) {\n                                v = 0;\n                            }\n                            value[ column_name ] = v;\n                        }\n                }\n            });\n        });\n        options.success( results );\n    };\n\n    /** Get block id */\n    var _block_id = function ( dataset_id, column ) {\n        return dataset_id + '_' + '_' + column;\n    };\n\n    return { request: request };\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./static/repository/visualizations/utilities/tabular-datasets.js\n ** module id = 5\n ** module chunks = 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 24\n **/"],"sourceRoot":""}