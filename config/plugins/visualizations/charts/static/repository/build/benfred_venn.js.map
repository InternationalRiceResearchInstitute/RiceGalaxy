{"version":3,"sources":["webpack:///benfred_venn.js","webpack:///webpack/bootstrap e3622d0033a89edad914?63f1*******************","webpack:///./static/repository/visualizations/benfred/venn/wrapper.js","webpack:///./static/repository/utilities/utils.js?825c*****************","webpack:///./static/repository/visualizations/utilities/tabular-datasets.js?bf7b*****************","webpack:///./~/css-loader/lib/css-base.js?da04*****************","webpack:///./~/style-loader/addStyles.js?b980*****************","webpack:///./static/repository/plugins/benfred/venn.css","webpack:///./static/repository/plugins/benfred/venn.css?4970","webpack:///./static/repository/plugins/benfred/venn.js"],"names":["define","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","0","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","Datasets","Venn","Backbone","View","extend","_combinations","current","remaining","results","self","this","_","each","value","index","new_current","slice","new_remaining","splice","push","initialize","options","request","dataset_id","chart","get","dataset_groups","groups","success","result","group_keys","group_values","all_values","group_ids","group","i","group_index","values","d","observation","key","combos","sets","size","found","group_id","length","set_labels","svg","d3","select","targets","datum","VennDiagram","tooltip","selectAll","on","sortAreas","append","attr","transition","duration","style","text","selection","event","pageY","remove","state","process","resolve","apply","undefined","1","clone","obj","JSON","parse","stringify","isJSON","test","replace","top","__utils__get__","cache_key","cache","window","console","debug","url","data","response","error","ajaxConfig","contentType","type","$","isEmptyObject","indexOf","param","dataType","ajax","done","jQuery","parseJSON","e","fail","response_text","responseText","always","complete","merge","optionsDefault","defaults","uid","__utils__uid__","5","Utils","_cache","column_list","column_def","column_name","column","block_id","_block_id","_fillFromCache","Galaxy","root","data_type","provider","indeces","toString","Array","row","j","v","limit","column_data","Math","max","dict","attributes","x","parseInt","isNaN","is_label","6","list","item","join","mediaQuery","alreadyImportedModules","7","addStylesToDom","styles","domStyle","stylesInDom","refs","parts","addStyle","listToStyles","newStyles","css","media","sourceMap","part","insertStyleElement","styleElement","head","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","nextSibling","insertBefore","appendChild","firstChild","Error","removeStyleElement","parentNode","removeChild","idx","createStyleElement","document","createElement","createLinkElement","linkElement","rel","update","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","bind","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","href","applyToTag","newObj","styleSheet","cssText","replaceText","cssNode","createTextNode","childNodes","setAttribute","unescape","encodeURIComponent","blob","oldSrc","memoize","fn","memo","arguments","isOldIE","navigator","userAgent","toLowerCase","getElementsByTagName","newList","mayRemove","textStore","replacement","filter","Boolean","66","159","content","locals","160","global","factory","bisect","f","a","b","parameters","maxIterations","tolerance","fA","fB","delta","mid","fMid","abs","zeros","r","zerosM","y","map","dot","ret","norm2","sqrt","multiplyBy","weightedSum","w1","v1","w2","v2","fmin","x0","maxDiff","temp","nonZeroDelta","zeroDelta","minErrorDelta","minTolerance","rho","chi","psi","sigma","callback","N","simplex","fx","point","sortOrder","centroid","reflected","contracted","expanded","iteration","sort","worst","shouldReduce","solution","minimizeConjugateGradient","initial","params","pk","fxprime","next","yk","history","wolfeLineSearch","delta_k","beta_k","zoom","a_lo","a_high","phi_lo","phi","phiPrime","phi0","c1","phiPrime0","c2","phi_old","a0","intersectionArea","circles","stats","intersectionPoints","getIntersectionPoints","innerPoints","containedInCircles","arcArea","polygonArea","arcs","center","getCenter","angle","atan2","p2","p1","midPoint","arc","parentIndex","circle","a1","a2","angleDiff","PI","width","distance","radius","sin","cos","circleArea","smallest","disjoint","SMALL","area","intersect","circleCircleIntersection","k","circleIntegral","circleOverlap","r1","r2","min","h","y0","rx","ry","points","venn","areas","initialLayout","bestInitialLayout","addMissingAreas","setid","setids","hasOwnProperty","totalFunctionCalls","lossFunction","positions","distanceFromIntersectArea","overlap","SMALL$1","ids","pairs","getDistanceMatrices","distances","constraints","left","right","constrainedMDSGradient","loss","xi","yi","xj","yj","dij","constraint","squaredDistance","greedyLayout","constrained","constrainedMDSLayout","constrainedLoss","greedyLoss","restarts","matrices","norm","best","random","set","isPositioned","element","positioned","positionSet","setOverlaps","rowid","weight","mostOverlapped","setIndex","d1","d2","extraPoints","l","bestLoss","bestPoint","overlaps","getCircles","indices","output","orientateCircles","orientation","orientationOrder","largestX","largestY","rotation","s","slope","disjointCluster","find","parent","union","xRoot","yRoot","maxDistance","disjointClusters","getBoundingBox","minMax","hi","lo","xRange","yRange","normalizeSolution","addCluster","cluster","bottom","xOffset","yOffset","centreing","bounds","returnBounds","spacing","previous","clusters","scaleSolution","height","padding","xScaling","yScaling","scaling","scaled","layoutFunction","normalize","textCentres","computeTextCentres","enter","hasPrevious","path","circleFromPath","pathTween","t","start","end","intersectionAreaPath","nodes","enterPath","enterText","label","styled","colours","attrTween","updateText","floor","wrap","wrapText","exit","exitText","fontSize","colourMap","colourScheme","colourIndex","labeller","joined","words","split","reverse","maxLines","minChars","word","pop","line","lineNumber","lineHeight","tspan","node","getComputedTextLength","circleMargin","interior","exterior","margin","computeTextCentre","valid","areaStats","getOverlappingCircles","circleids","circleid","overlapped","areaids","exclude","centre","log","div","relativeTo","shouldExclude","check","circlePath","tokens","parseFloat","wide"],"mappings":"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","file":"benfred_venn.js","sourcesContent":["define(function() { return /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(5), __webpack_require__(160), __webpack_require__(159) ], __WEBPACK_AMD_DEFINE_RESULT__ = function( Datasets, Venn ) {\n\t    return Backbone.View.extend({\n\t        _combinations: function( current, remaining, results ) {\n\t            var self = this;\n\t            _.each( remaining, function( value, index ) {\n\t                var new_current = current.slice();\n\t                var new_remaining = remaining.slice();\n\t                new_remaining.splice( 0, index + 1 );\n\t                new_current.push( value );\n\t                results.push( new_current );\n\t                self._combinations( new_current, new_remaining, results );\n\t            });\n\t        },\n\t\n\t        initialize: function( options ) {\n\t            var self = this;\n\t            var separator = '_';\n\t            Datasets.request({\n\t                dataset_id      : options.chart.get( 'dataset_id' ),\n\t                dataset_groups  : options.chart.groups,\n\t                success         : function( result ) {\n\t                    var group_keys   = [];\n\t                    var group_values = [];\n\t                    var all_values   = {};\n\t                    var set_size     = {};\n\t                    var group_ids    = [];\n\t                    _.each( result, function( group, i ) {\n\t                        var group_index = {};\n\t                        _.each( group.values, function( d ) {\n\t                            all_values[ d.observation ] = group_index[ d.observation ] = true;\n\t                        });\n\t                        group_keys.push( group.key );\n\t                        group_values.push( group_index );\n\t                        group_ids.push( i );\n\t                    });\n\t                    var combos = [];\n\t                    self._combinations( [], group_ids, combos );\n\t                    var sets = [];\n\t                    _.each( combos, function( c ) {\n\t                        var size = 0;\n\t                        for ( var value in all_values ) {\n\t                            var found = 0;\n\t                            _.each( c, function( group_id ) {\n\t                                if ( group_values[ group_id ][ value ] ) {\n\t                                    found++;\n\t                                }\n\t                            });\n\t                            if ( found == c.length ) {\n\t                                size++;\n\t                            }\n\t                        }\n\t                        if ( size > 0 ) {\n\t                            var set_labels = [];\n\t                            _.each( c, function( id ) {\n\t                                set_labels.push( group_keys[ id ]);\n\t                            });\n\t                            sets.push( { sets: set_labels, size: size } );\n\t                        }\n\t                    });\n\t                    var svg = d3.select( '#' + options.targets[ 0 ] ).datum( sets ).call( Venn.VennDiagram() );\n\t                    var tooltip = null;\n\t                    svg.selectAll( 'g' )\n\t                       .on( 'mouseover', function( d, i ) {\n\t                            Venn.sortAreas( svg, d );\n\t                            tooltip = d3.select( 'body' ).append( 'div' ).attr( 'class', 'venntooltip' );\n\t                            tooltip.transition().duration( 400 ).style( 'opacity', .9 );\n\t                            tooltip.text(d.size );\n\t                            var selection = d3.select( this ).transition( 'tooltip' ).duration( 400 );\n\t                            selection.select( 'path' )\n\t                                     .style( 'stroke-width', 3 )\n\t                                     .style( 'fill-opacity', d.sets.length == 1 ? .4 : .1 )\n\t                                     .style( 'stroke-opacity', 1 );\n\t                       })\n\t                       .on( 'mousemove', function() {\n\t                            tooltip.style( 'left', ( d3.event.pageX ) + 'px')\n\t                                   .style( 'top', ( d3.event.pageY - 28 ) + 'px');\n\t                       })\n\t                       .on( 'mouseout', function( d, i ) {\n\t                            tooltip.remove();\n\t                       });\n\t                    options.chart.state( 'ok', 'Venn diagram drawn.' );\n\t                    options.process.resolve();\n\t                }\n\t            });\n\t        }\n\t    });\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n\n/***/ 1:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** Useful helper functions */\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\n\t    /** Clone */\n\t    function clone( obj ) {\n\t        return JSON.parse( JSON.stringify( obj ) || null );\n\t    };\n\t\n\t    /**\n\t     * Check if a string is a json string\n\t     * @param{String}   text - Content to be validated\n\t     */\n\t    function isJSON(text) {\n\t        return /^[\\],:{}\\s]*$/.test(text.replace(/\\\\[\"\\\\\\/bfnrtu]/g, '@').\n\t            replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']').\n\t            replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''));\n\t    };\n\t\n\t    /**\n\t     * Request handler for GET\n\t     * @param{String}   url     - Url request is made to\n\t     * @param{Function} success - Callback on success\n\t     * @param{Function} error   - Callback on error\n\t     * @param{Boolean}  cache   - Use cached data if available\n\t     */\n\t    function get (options) {\n\t        top.__utils__get__ = top.__utils__get__ || {};\n\t        var cache_key = JSON.stringify( options );\n\t        if (options.cache && top.__utils__get__[cache_key]) {\n\t            options.success && options.success(top.__utils__get__[cache_key]);\n\t            window.console.debug('utils.js::get() - Fetching from cache [' + options.url + '].');\n\t        } else {\n\t            request({\n\t                url     : options.url,\n\t                data    : options.data,\n\t                success : function(response) {\n\t                    top.__utils__get__[cache_key] = response;\n\t                    options.success && options.success(response);\n\t                },\n\t                error : function(response) {\n\t                    options.error && options.error(response);\n\t                }\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Request handler\n\t     * @param{String}   method  - Request method ['GET', 'POST', 'DELETE', 'PUT']\n\t     * @param{String}   url     - Url request is made to\n\t     * @param{Object}   data    - Data send to url\n\t     * @param{Function} success - Callback on success\n\t     * @param{Function} error   - Callback on error\n\t     */\n\t    function request (options) {\n\t        var ajaxConfig = {\n\t            contentType : 'application/json',\n\t            type        : options.type || 'GET',\n\t            data        : options.data || {},\n\t            url         : options.url\n\t        }\n\t        if ( ajaxConfig.type == 'GET' || ajaxConfig.type == 'DELETE' ) {\n\t            if ( !$.isEmptyObject(ajaxConfig.data) ) {\n\t                ajaxConfig.url += ajaxConfig.url.indexOf('?') == -1 ? '?' : '&';\n\t                ajaxConfig.url += $.param(ajaxConfig.data, true);\n\t            }\n\t            ajaxConfig.data = null;\n\t        } else {\n\t            ajaxConfig.dataType = 'json';\n\t            ajaxConfig.url      = ajaxConfig.url;\n\t            ajaxConfig.data     = JSON.stringify( ajaxConfig.data );\n\t        }\n\t        $.ajax( ajaxConfig ).done( function( response ) {\n\t            if ( typeof response === 'string' && isJSON( response ) ) {\n\t                try {\n\t                    response = response.replace( 'Infinity,', '\"Infinity\",' );\n\t                    response = jQuery.parseJSON( response );\n\t                } catch ( e ) {\n\t                    console.debug( e );\n\t                }\n\t            }\n\t            options.success && options.success( response );\n\t        }).fail( function( response ) {\n\t            var response_text = null;\n\t            try {\n\t                response_text = jQuery.parseJSON( response.responseText );\n\t            } catch (e) {\n\t                response_text = response.responseText;\n\t            }\n\t            options.error && options.error( response_text, response );\n\t        }).always( function() {\n\t            options.complete && options.complete();\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Safely merge to dictionaries\n\t     * @param{Object}   options         - Target dictionary\n\t     * @param{Object}   optionsDefault  - Source dictionary\n\t     */\n\t    function merge (options, optionsDefault) {\n\t        if (options) {\n\t            return _.defaults(options, optionsDefault);\n\t        } else {\n\t            return optionsDefault;\n\t        }\n\t    };\n\t\n\t    /** Create a unique id */\n\t    function uid(){\n\t        top.__utils__uid__ = top.__utils__uid__ || 0;\n\t        return 'uid-' + top.__utils__uid__++;\n\t    };\n\t\n\t    return {\n\t        get     : get,\n\t        merge   : merge,\n\t        uid     : uid,\n\t        request : request,\n\t        clone   : clone,\n\t        isJSON  : isJSON\n\t    };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n\n/***/ 5:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/** This class handles, formats and caches datasets. */\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(1) ], __WEBPACK_AMD_DEFINE_RESULT__ = function( Utils ) {\n\t    /** Fills request dictionary with data from cache/response */\n\t    var _cache = {};\n\t    var request = function( options ) {\n\t        var groups      = options.dataset_groups;\n\t        var dataset_id  = options.dataset_id;\n\t        // identify columns needed to fulfill request\n\t        var column_list = [];\n\t        groups.each( function( group ) {\n\t            _.each( group.get( '__data_columns' ), function( column_def, column_name ) {\n\t                var column = group.get( column_name );\n\t                var block_id = _block_id( dataset_id, column );\n\t                if ( column_list.indexOf( column ) === -1 && !_cache[ block_id ] && column != 'auto' && column != 'zero' && column !== undefined ) {\n\t                    column_list.push( column );\n\t                }\n\t            });\n\t        });\n\t        if ( column_list.length == 0 ) {\n\t            _fillFromCache( options );\n\t            return;\n\t        }\n\t        // Fetch data columns into dataset object\n\t        Utils.get({\n\t            url     : Galaxy.root + 'api/datasets/' + dataset_id,\n\t            data    : {\n\t                data_type   : 'raw_data',\n\t                provider    : 'dataset-column',\n\t                indeces     : column_list.toString()\n\t            },\n\t            success : function( response ) {\n\t                var results = new Array( column_list.length );\n\t                for ( var i = 0; i < results.length; i++ ) {\n\t                    results[ i ] = [];\n\t                }\n\t                for ( var i in response.data ) {\n\t                    var row = response.data[ i ];\n\t                    for ( var j in row ) {\n\t                        var v = row[ j ];\n\t                        if ( v !== undefined && v != 2147483647 ) {\n\t                            results[ j ].push( v );\n\t                        }\n\t                    }\n\t                }\n\t                console.debug( 'tabular-datasets::_fetch() - Fetching complete.' );\n\t                for ( var i in results ) {\n\t                    var column = column_list[ i ];\n\t                    var block_id = _block_id( dataset_id, column );\n\t                    _cache[ block_id ] = results[ i ];\n\t                }\n\t                _fillFromCache( options );\n\t            }\n\t        });\n\t    };\n\t\n\t    /** Fill data from cache */\n\t    var _fillFromCache = function( options ) {\n\t        var groups      = options.dataset_groups;\n\t        var dataset_id  = options.dataset_id;\n\t        console.debug( 'tabular-datasets::_fillFromCache() - Filling request from cache.' );\n\t        var limit = 0;\n\t        groups.each( function( group ) {\n\t            _.each( group.get( '__data_columns' ), function( column_def, column_name ) {\n\t                var column = group.get( column_name );\n\t                var block_id = _block_id( dataset_id, column );\n\t                var column_data = _cache[ block_id ];\n\t                if ( column_data ) {\n\t                    limit = Math.max( limit, column_data.length );\n\t                }\n\t            });\n\t        });\n\t        if ( limit == 0 ) {\n\t            console.debug( 'tabular-datasets::_fillFromCache() - No data available.' );\n\t        }\n\t        var results = [];\n\t        groups.each( function( group, group_index ) {\n\t            var dict = Utils.merge( { key: ( group_index ) + ':' + group.get( 'key' ), values: [] }, group.attributes );\n\t            for ( var j = 0; j < limit; j++ ) {\n\t                dict.values[ j ] = { x : parseInt( j ) };\n\t            }\n\t            results.push( dict );\n\t        });\n\t        groups.each( function( group, group_index ) {\n\t            var values = results[ group_index ].values;\n\t            _.each( group.get( '__data_columns' ), function( column_def, column_name ) {\n\t                var column = group.get( column_name );\n\t                switch ( column ) {\n\t                    case 'auto':\n\t                        for ( var j = 0; j < limit; j++ ) {\n\t                            values[ j ][ column_name ] = parseInt( j );\n\t                        }\n\t                        break;\n\t                    case 'zero':\n\t                        for ( var j = 0; j < limit; j++ ) {\n\t                            values[ j ][ column_name ] = 0;\n\t                        }\n\t                        break;\n\t                    default:\n\t                        var block_id = _block_id( dataset_id, column );\n\t                        var column_data = _cache[ block_id ];\n\t                        for ( var j = 0; j < limit; j++ ) {\n\t                            var value = values[ j ];\n\t                            var v = column_data[ j ];\n\t                            if ( isNaN( v ) && !column_def.is_label ) {\n\t                                v = 0;\n\t                            }\n\t                            value[ column_name ] = v;\n\t                        }\n\t                }\n\t            });\n\t        });\n\t        options.success( results );\n\t    };\n\t\n\t    /** Get block id */\n\t    var _block_id = function ( dataset_id, column ) {\n\t        return dataset_id + '_' + '_' + column;\n\t    };\n\t\n\t    return { request: request };\n\t}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/***/ },\n\n/***/ 6:\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n\n/***/ 7:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {},\r\n\t\tmemoize = function(fn) {\r\n\t\t\tvar memo;\r\n\t\t\treturn function () {\r\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\t\treturn memo;\r\n\t\t\t};\r\n\t\t},\r\n\t\tisOldIE = memoize(function() {\r\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t\t}),\r\n\t\tgetHeadElement = memoize(function () {\r\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\t}),\r\n\t\tsingletonElement = null,\r\n\t\tsingletonCounter = 0,\r\n\t\tstyleElementsInsertedAtTop = [];\r\n\t\r\n\tmodule.exports = function(list, options) {\r\n\t\tif(false) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\r\n\t\toptions = options || {};\r\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t\t// tags it will allow on a page\r\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\t\r\n\t\t// By default, add <style> tags to the bottom of <head>.\r\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\t\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles, options);\r\n\t\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles, options);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles, options) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\tvar sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction insertStyleElement(options, styleElement) {\r\n\t\tvar head = getHeadElement();\r\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\t\tif (options.insertAt === \"top\") {\r\n\t\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t\t} else {\r\n\t\t\t\thead.appendChild(styleElement);\r\n\t\t\t}\r\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t\t} else if (options.insertAt === \"bottom\") {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction removeStyleElement(styleElement) {\r\n\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\t\tif(idx >= 0) {\r\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction createStyleElement(options) {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\tinsertStyleElement(options, styleElement);\r\n\t\treturn styleElement;\r\n\t}\r\n\t\r\n\tfunction createLinkElement(options) {\r\n\t\tvar linkElement = document.createElement(\"link\");\r\n\t\tlinkElement.rel = \"stylesheet\";\r\n\t\tinsertStyleElement(options, linkElement);\r\n\t\treturn linkElement;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj, options) {\r\n\t\tvar styleElement, update, remove;\r\n\t\r\n\t\tif (options.singleton) {\r\n\t\t\tvar styleIndex = singletonCounter++;\r\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t\t} else if(obj.sourceMap &&\r\n\t\t\ttypeof URL === \"function\" &&\r\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\t\ttypeof Blob === \"function\" &&\r\n\t\t\ttypeof btoa === \"function\") {\r\n\t\t\tstyleElement = createLinkElement(options);\r\n\t\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t\tif(styleElement.href)\r\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tstyleElement = createStyleElement(options);\r\n\t\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tupdate(obj);\r\n\t\r\n\t\treturn function updateStyle(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tupdate(obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\tremove();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar replaceText = (function () {\r\n\t\tvar textStore = [];\r\n\t\r\n\t\treturn function (index, replacement) {\r\n\t\t\ttextStore[index] = replacement;\r\n\t\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t\t};\r\n\t})();\r\n\t\r\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\t\tvar css = remove ? \"\" : obj.css;\r\n\t\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t\t} else {\r\n\t\t\tvar cssNode = document.createTextNode(css);\r\n\t\t\tvar childNodes = styleElement.childNodes;\r\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\t\tif (childNodes.length) {\r\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t\t} else {\r\n\t\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\r\n\t\tif(styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updateLink(linkElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(sourceMap) {\r\n\t\t\t// http://stackoverflow.com/a/26603875\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t\t}\r\n\t\r\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\t\r\n\t\tvar oldSrc = linkElement.href;\r\n\t\r\n\t\tlinkElement.href = URL.createObjectURL(blob);\r\n\t\r\n\t\tif(oldSrc)\r\n\t\t\tURL.revokeObjectURL(oldSrc);\r\n\t}\r\n\n\n/***/ },\n\n/***/ 66:\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(6)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".venntooltip{position:absolute;text-align:center;width:128px;height:22px;background:#333;color:#ddd;border:0;border-radius:8px;opacity:0}.venn-area>.label{font-size:1em}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n\n/***/ 159:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(66);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(7)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./venn.css\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./venn.css\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n\n/***/ 160:\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (global, factory) {\n\t     true ? factory(exports) :\n\t    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t    factory((global.venn = {}),global.d3,global.d3);\n\t}(this, function (exports) { 'use strict';\n\t\n\t    /** finds the zeros of a function, given two starting points (which must\n\t     * have opposite signs */\n\t    function bisect(f, a, b, parameters) {\n\t        parameters = parameters || {};\n\t        var maxIterations = parameters.maxIterations || 100,\n\t            tolerance = parameters.tolerance || 1e-10,\n\t            fA = f(a),\n\t            fB = f(b),\n\t            delta = b - a;\n\t\n\t        if (fA * fB > 0) {\n\t            throw \"Initial bisect points must have opposite signs\";\n\t        }\n\t\n\t        if (fA === 0) return a;\n\t        if (fB === 0) return b;\n\t\n\t        for (var i = 0; i < maxIterations; ++i) {\n\t            delta /= 2;\n\t            var mid = a + delta,\n\t                fMid = f(mid);\n\t\n\t            if (fMid * fA >= 0) {\n\t                a = mid;\n\t            }\n\t\n\t            if ((Math.abs(delta) < tolerance) || (fMid === 0)) {\n\t                return mid;\n\t            }\n\t        }\n\t        return a + delta;\n\t    }\n\t\n\t    // need some basic operations on vectors, rather than adding a dependency,\n\t    // just define here\n\t    function zeros(x) { var r = new Array(x); for (var i = 0; i < x; ++i) { r[i] = 0; } return r; }\n\t    function zerosM(x,y) { return zeros(x).map(function() { return zeros(y); }); }\n\t\n\t    function dot(a, b) {\n\t        var ret = 0;\n\t        for (var i = 0; i < a.length; ++i) {\n\t            ret += a[i] * b[i];\n\t        }\n\t        return ret;\n\t    }\n\t\n\t    function norm2(a)  {\n\t        return Math.sqrt(dot(a, a));\n\t    }\n\t\n\t    function multiplyBy(a, c) {\n\t        for (var i = 0; i < a.length; ++i) {\n\t            a[i] *= c;\n\t        }\n\t    }\n\t\n\t    function weightedSum(ret, w1, v1, w2, v2) {\n\t        for (var j = 0; j < ret.length; ++j) {\n\t            ret[j] = w1 * v1[j] + w2 * v2[j];\n\t        }\n\t    }\n\t\n\t    /** minimizes a function using the downhill simplex method */\n\t    function fmin(f, x0, parameters) {\n\t        parameters = parameters || {};\n\t\n\t        var maxIterations = parameters.maxIterations || x0.length * 200,\n\t            nonZeroDelta = parameters.nonZeroDelta || 1.1,\n\t            zeroDelta = parameters.zeroDelta || 0.001,\n\t            minErrorDelta = parameters.minErrorDelta || 1e-6,\n\t            minTolerance = parameters.minErrorDelta || 1e-5,\n\t            rho = parameters.rho || 1,\n\t            chi = parameters.chi || 2,\n\t            psi = parameters.psi || -0.5,\n\t            sigma = parameters.sigma || 0.5,\n\t            callback = parameters.callback,\n\t            maxDiff,\n\t            temp;\n\t\n\t        // initialize simplex.\n\t        var N = x0.length,\n\t            simplex = new Array(N + 1);\n\t        simplex[0] = x0;\n\t        simplex[0].fx = f(x0);\n\t        for (var i = 0; i < N; ++i) {\n\t            var point = x0.slice();\n\t            point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n\t            simplex[i+1] = point;\n\t            simplex[i+1].fx = f(point);\n\t        }\n\t\n\t        var sortOrder = function(a, b) { return a.fx - b.fx; };\n\t\n\t        var centroid = x0.slice(),\n\t            reflected = x0.slice(),\n\t            contracted = x0.slice(),\n\t            expanded = x0.slice();\n\t\n\t        for (var iteration = 0; iteration < maxIterations; ++iteration) {\n\t            simplex.sort(sortOrder);\n\t            if (callback) {\n\t                callback(simplex);\n\t            }\n\t\n\t            maxDiff = 0;\n\t            for (i = 0; i < N; ++i) {\n\t                maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n\t            }\n\t\n\t            if ((Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) &&\n\t                (maxDiff < minTolerance)) {\n\t                break;\n\t            }\n\t\n\t            // compute the centroid of all but the worst point in the simplex\n\t            for (i = 0; i < N; ++i) {\n\t                centroid[i] = 0;\n\t                for (var j = 0; j < N; ++j) {\n\t                    centroid[i] += simplex[j][i];\n\t                }\n\t                centroid[i] /= N;\n\t            }\n\t\n\t            // reflect the worst point past the centroid  and compute loss at reflected\n\t            // point\n\t            var worst = simplex[N];\n\t            weightedSum(reflected, 1+rho, centroid, -rho, worst);\n\t            reflected.fx = f(reflected);\n\t\n\t            // if the reflected point is the best seen, then possibly expand\n\t            if (reflected.fx <= simplex[0].fx) {\n\t                weightedSum(expanded, 1+chi, centroid, -chi, worst);\n\t                expanded.fx = f(expanded);\n\t                if (expanded.fx < reflected.fx) {\n\t                    temp = simplex[N];\n\t                    simplex[N] = expanded;\n\t                    expanded = temp;\n\t                }  else {\n\t                    temp = simplex[N];\n\t                    simplex[N] = reflected;\n\t                    reflected = temp;\n\t                }\n\t            }\n\t\n\t            // if the reflected point is worse than the second worst, we need to\n\t            // contract\n\t            else if (reflected.fx >= simplex[N-1].fx) {\n\t                var shouldReduce = false;\n\t\n\t                if (reflected.fx > worst.fx) {\n\t                    // do an inside contraction\n\t                    weightedSum(contracted, 1+psi, centroid, -psi, worst);\n\t                    contracted.fx = f(contracted);\n\t                    if (contracted.fx < worst.fx) {\n\t                        temp = simplex[N];\n\t                        simplex[N] = contracted;\n\t                        contracted = temp;\n\t                    } else {\n\t                        shouldReduce = true;\n\t                    }\n\t                } else {\n\t                    // do an outside contraction\n\t                    weightedSum(contracted, 1-psi * rho, centroid, psi*rho, worst);\n\t                    contracted.fx = f(contracted);\n\t                    if (contracted.fx <= reflected.fx) {\n\t                        temp = simplex[N];\n\t                        simplex[N] = contracted;\n\t                        contracted = temp;\n\t                    } else {\n\t                        shouldReduce = true;\n\t                    }\n\t                }\n\t\n\t                if (shouldReduce) {\n\t                    // do reduction. doesn't actually happen that often\n\t                    for (i = 1; i < simplex.length; ++i) {\n\t                        weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n\t                        simplex[i].fx = f(simplex[i]);\n\t                    }\n\t                }\n\t            } else {\n\t                temp = simplex[N];\n\t                simplex[N] = reflected;\n\t                reflected = temp;\n\t            }\n\t\n\t        }\n\t\n\t        simplex.sort(sortOrder);\n\t        return {f : simplex[0].fx,\n\t                solution : simplex[0]};\n\t    }\n\t\n\t    function minimizeConjugateGradient(f, initial, params) {\n\t        // allocate all memory up front here, keep out of the loop for perfomance\n\t        // reasons\n\t        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n\t            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n\t            yk = initial.slice(),\n\t            pk, temp,\n\t            a = 1,\n\t            maxIterations;\n\t\n\t        params = params || {};\n\t        maxIterations = params.maxIterations || initial.length * 5;\n\t\n\t        current.fx = f(current.x, current.fxprime);\n\t        pk = current.fxprime.slice();\n\t        multiplyBy(pk, -1);\n\t\n\t        for (var i = 0; i < maxIterations; ++i) {\n\t            if (params.history) {\n\t                params.history.push({x: current.x.slice(),\n\t                                     fx: current.fx,\n\t                                     fxprime: current.fxprime.slice()});\n\t            }\n\t\n\t            a = wolfeLineSearch(f, pk, current, next, a);\n\t            if (!a) {\n\t                // faiiled to find point that satifies wolfe conditions.\n\t                // reset direction for next iteration\n\t                for (var j = 0; j < pk.length; ++j) {\n\t                    pk[j] = -1 * current.fxprime[j];\n\t                }\n\t            } else {\n\t                // update direction using Polak–Ribiere CG method\n\t                weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\n\t\n\t                var delta_k = dot(current.fxprime, current.fxprime),\n\t                    beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\n\t\n\t                weightedSum(pk, beta_k, pk, -1, next.fxprime);\n\t\n\t                temp = current;\n\t                current = next;\n\t                next = temp;\n\t            }\n\t\n\t            if (norm2(current.fxprime) <= 1e-5) {\n\t                break;\n\t            }\n\t        }\n\t\n\t        if (params.history) {\n\t            params.history.push({x: current.x.slice(),\n\t                                 fx: current.fx,\n\t                                 fxprime: current.fxprime.slice()});\n\t        }\n\t\n\t        return current;\n\t    }\n\t\n\t    var c1 = 1e-6;\n\t    var c2 = 0.1;\n\t    /// searches along line 'pk' for a point that satifies the wolfe conditions\n\t    /// See 'Numerical Optimization' by Nocedal and Wright p59-60\n\t    function wolfeLineSearch(f, pk, current, next, a) {\n\t        var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk),\n\t            phi = phi0, phi_old = phi0,\n\t            phiPrime = phiPrime0,\n\t            a0 = 0;\n\t\n\t        a = a || 1;\n\t\n\t        function zoom(a_lo, a_high, phi_lo) {\n\t            for (var iteration = 0; iteration < 16; ++iteration) {\n\t                a = (a_lo + a_high)/2;\n\t                weightedSum(next.x, 1.0, current.x, a, pk);\n\t                phi = next.fx = f(next.x, next.fxprime);\n\t                phiPrime = dot(next.fxprime, pk);\n\t\n\t                if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n\t                    (phi >= phi_lo)) {\n\t                    a_high = a;\n\t\n\t                } else  {\n\t                    if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n\t                        return a;\n\t                    }\n\t\n\t                    if (phiPrime * (a_high - a_lo) >=0) {\n\t                        a_high = a_lo;\n\t                    }\n\t\n\t                    a_lo = a;\n\t                    phi_lo = phi;\n\t                }\n\t            }\n\t\n\t            return 0;\n\t        }\n\t\n\t        for (var iteration = 0; iteration < 10; ++iteration) {\n\t            weightedSum(next.x, 1.0, current.x, a, pk);\n\t            phi = next.fx = f(next.x, next.fxprime);\n\t            phiPrime = dot(next.fxprime, pk);\n\t            if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n\t                (iteration && (phi >= phi_old))) {\n\t                return zoom(a0, a, phi_old);\n\t            }\n\t\n\t            if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n\t                return a;\n\t            }\n\t\n\t            if (phiPrime >= 0 ) {\n\t                return zoom(a, a0, phi);\n\t            }\n\t\n\t            phi_old = phi;\n\t            a0 = a;\n\t            a *= 2;\n\t        }\n\t\n\t        return 0;\n\t    }\n\t\n\t    var SMALL = 1e-10;\n\t\n\t    /** Returns the intersection area of a bunch of circles (where each circle\n\t     is an object having an x,y and radius property) */\n\t    function intersectionArea(circles, stats) {\n\t        // get all the intersection points of the circles\n\t        var intersectionPoints = getIntersectionPoints(circles);\n\t\n\t        // filter out points that aren't included in all the circles\n\t        var innerPoints = intersectionPoints.filter(function (p) {\n\t            return containedInCircles(p, circles);\n\t        });\n\t\n\t        var arcArea = 0, polygonArea = 0, arcs = [], i;\n\t\n\t        // if we have intersection points that are within all the circles,\n\t        // then figure out the area contained by them\n\t        if (innerPoints.length > 1) {\n\t            // sort the points by angle from the center of the polygon, which lets\n\t            // us just iterate over points to get the edges\n\t            var center = getCenter(innerPoints);\n\t            for (i = 0; i < innerPoints.length; ++i ) {\n\t                var p = innerPoints[i];\n\t                p.angle = Math.atan2(p.x - center.x, p.y - center.y);\n\t            }\n\t            innerPoints.sort(function(a,b) { return b.angle - a.angle;});\n\t\n\t            // iterate over all points, get arc between the points\n\t            // and update the areas\n\t            var p2 = innerPoints[innerPoints.length - 1];\n\t            for (i = 0; i < innerPoints.length; ++i) {\n\t                var p1 = innerPoints[i];\n\t\n\t                // polygon area updates easily ...\n\t                polygonArea += (p2.x + p1.x) * (p1.y - p2.y);\n\t\n\t                // updating the arc area is a little more involved\n\t                var midPoint = {x : (p1.x + p2.x) / 2,\n\t                                y : (p1.y + p2.y) / 2},\n\t                    arc = null;\n\t\n\t                for (var j = 0; j < p1.parentIndex.length; ++j) {\n\t                    if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {\n\t                        // figure out the angle halfway between the two points\n\t                        // on the current circle\n\t                        var circle = circles[p1.parentIndex[j]],\n\t                            a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),\n\t                            a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);\n\t\n\t                        var angleDiff = (a2 - a1);\n\t                        if (angleDiff < 0) {\n\t                            angleDiff += 2*Math.PI;\n\t                        }\n\t\n\t                        // and use that angle to figure out the width of the\n\t                        // arc\n\t                        var a = a2 - angleDiff/2,\n\t                            width = distance(midPoint, {\n\t                                x : circle.x + circle.radius * Math.sin(a),\n\t                                y : circle.y + circle.radius * Math.cos(a)\n\t                            });\n\t\n\t                        // pick the circle whose arc has the smallest width\n\t                        if ((arc === null) || (arc.width > width)) {\n\t                            arc = { circle : circle,\n\t                                    width : width,\n\t                                    p1 : p1,\n\t                                    p2 : p2};\n\t                        }\n\t                    }\n\t                }\n\t\n\t                if (arc !== null) {\n\t                    arcs.push(arc);\n\t                    arcArea += circleArea(arc.circle.radius, arc.width);\n\t                    p2 = p1;\n\t                }\n\t            }\n\t        } else {\n\t            // no intersection points, is either disjoint - or is completely\n\t            // overlapped. figure out which by examining the smallest circle\n\t            var smallest = circles[0];\n\t            for (i = 1; i < circles.length; ++i) {\n\t                if (circles[i].radius < smallest.radius) {\n\t                    smallest = circles[i];\n\t                }\n\t            }\n\t\n\t            // make sure the smallest circle is completely contained in all\n\t            // the other circles\n\t            var disjoint = false;\n\t            for (i = 0; i < circles.length; ++i) {\n\t                if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {\n\t                    disjoint = true;\n\t                    break;\n\t                }\n\t            }\n\t\n\t            if (disjoint) {\n\t                arcArea = polygonArea = 0;\n\t\n\t            } else {\n\t                arcArea = smallest.radius * smallest.radius * Math.PI;\n\t                arcs.push({circle : smallest,\n\t                           p1: { x: smallest.x,        y : smallest.y + smallest.radius},\n\t                           p2: { x: smallest.x - SMALL, y : smallest.y + smallest.radius},\n\t                           width : smallest.radius * 2 });\n\t            }\n\t        }\n\t\n\t        polygonArea /= 2;\n\t        if (stats) {\n\t            stats.area = arcArea + polygonArea;\n\t            stats.arcArea = arcArea;\n\t            stats.polygonArea = polygonArea;\n\t            stats.arcs = arcs;\n\t            stats.innerPoints = innerPoints;\n\t            stats.intersectionPoints = intersectionPoints;\n\t        }\n\t\n\t        return arcArea + polygonArea;\n\t    }\n\t\n\t    /** returns whether a point is contained by all of a list of circles */\n\t    function containedInCircles(point, circles) {\n\t        for (var i = 0; i < circles.length; ++i) {\n\t            if (distance(point, circles[i]) > circles[i].radius + SMALL) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    /** Gets all intersection points between a bunch of circles */\n\t    function getIntersectionPoints(circles) {\n\t        var ret = [];\n\t        for (var i = 0; i < circles.length; ++i) {\n\t            for (var j = i + 1; j < circles.length; ++j) {\n\t                var intersect = circleCircleIntersection(circles[i],\n\t                                                              circles[j]);\n\t                for (var k = 0; k < intersect.length; ++k) {\n\t                    var p = intersect[k];\n\t                    p.parentIndex = [i,j];\n\t                    ret.push(p);\n\t                }\n\t            }\n\t        }\n\t        return ret;\n\t    }\n\t\n\t    function circleIntegral(r, x) {\n\t        var y = Math.sqrt(r * r - x * x);\n\t        return x * y + r * r * Math.atan2(x, y);\n\t    }\n\t\n\t    /** Returns the area of a circle of radius r - up to width */\n\t    function circleArea(r, width) {\n\t        return circleIntegral(r, width - r) - circleIntegral(r, -r);\n\t    }\n\t\n\t    /** euclidean distance between two points */\n\t    function distance(p1, p2) {\n\t        return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) +\n\t                         (p1.y - p2.y) * (p1.y - p2.y));\n\t    }\n\t\n\t\n\t    /** Returns the overlap area of two circles of radius r1 and r2 - that\n\t    have their centers separated by distance d. Simpler faster\n\t    circle intersection for only two circles */\n\t    function circleOverlap(r1, r2, d) {\n\t        // no overlap\n\t        if (d >= r1 + r2) {\n\t            return 0;\n\t        }\n\t\n\t        // completely overlapped\n\t        if (d <= Math.abs(r1 - r2)) {\n\t            return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);\n\t        }\n\t\n\t        var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),\n\t            w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);\n\t        return circleArea(r1, w1) + circleArea(r2, w2);\n\t    }\n\t\n\t    /** Given two circles (containing a x/y/radius attributes),\n\t    returns the intersecting points if possible.\n\t    note: doesn't handle cases where there are infinitely many\n\t    intersection points (circles are equivalent):, or only one intersection point*/\n\t    function circleCircleIntersection(p1, p2) {\n\t        var d = distance(p1, p2),\n\t            r1 = p1.radius,\n\t            r2 = p2.radius;\n\t\n\t        // if to far away, or self contained - can't be done\n\t        if ((d >= (r1 + r2)) || (d <= Math.abs(r1 - r2))) {\n\t            return [];\n\t        }\n\t\n\t        var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),\n\t            h = Math.sqrt(r1 * r1 - a * a),\n\t            x0 = p1.x + a * (p2.x - p1.x) / d,\n\t            y0 = p1.y + a * (p2.y - p1.y) / d,\n\t            rx = -(p2.y - p1.y) * (h / d),\n\t            ry = -(p2.x - p1.x) * (h / d);\n\t\n\t        return [{x: x0 + rx, y : y0 - ry },\n\t                {x: x0 - rx, y : y0 + ry }];\n\t    }\n\t\n\t    /** Returns the center of a bunch of points */\n\t    function getCenter(points) {\n\t        var center = {x: 0, y: 0};\n\t        for (var i =0; i < points.length; ++i ) {\n\t            center.x += points[i].x;\n\t            center.y += points[i].y;\n\t        }\n\t        center.x /= points.length;\n\t        center.y /= points.length;\n\t        return center;\n\t    }\n\t\n\t    /** given a list of set objects, and their corresponding overlaps.\n\t    updates the (x, y, radius) attribute on each set such that their positions\n\t    roughly correspond to the desired overlaps */\n\t    function venn(areas, parameters) {\n\t        parameters = parameters || {};\n\t        parameters.maxIterations = parameters.maxIterations || 500;\n\t        var initialLayout = parameters.initialLayout || bestInitialLayout;\n\t\n\t        // add in missing pairwise areas as having 0 size\n\t        areas = addMissingAreas(areas);\n\t\n\t        // initial layout is done greedily\n\t        var circles = initialLayout(areas);\n\t\n\t        // transform x/y coordinates to a vector to optimize\n\t        var initial = [], setids = [], setid;\n\t        for (setid in circles) {\n\t            if (circles.hasOwnProperty(setid)) {\n\t                initial.push(circles[setid].x);\n\t                initial.push(circles[setid].y);\n\t                setids.push(setid);\n\t            }\n\t        }\n\t\n\t        // optimize initial layout from our loss function\n\t        var totalFunctionCalls = 0;\n\t        var solution = fmin(\n\t            function(values) {\n\t                totalFunctionCalls += 1;\n\t                var current = {};\n\t                for (var i = 0; i < setids.length; ++i) {\n\t                    var setid = setids[i];\n\t                    current[setid] = {x: values[2 * i],\n\t                                      y: values[2 * i + 1],\n\t                                      radius : circles[setid].radius,\n\t                                     // size : circles[setid].size\n\t                                     };\n\t                }\n\t                return lossFunction(current, areas);\n\t            },\n\t            initial,\n\t            parameters);\n\t\n\t        // transform solution vector back to x/y points\n\t        var positions = solution.solution;\n\t        for (var i = 0; i < setids.length; ++i) {\n\t            setid = setids[i];\n\t            circles[setid].x = positions[2 * i];\n\t            circles[setid].y = positions[2 * i + 1];\n\t        }\n\t\n\t        return circles;\n\t    }\n\t\n\t    var SMALL$1 = 1e-10;\n\t\n\t    /** Returns the distance necessary for two circles of radius r1 + r2 to\n\t    have the overlap area 'overlap' */\n\t    function distanceFromIntersectArea(r1, r2, overlap) {\n\t        // handle complete overlapped circles\n\t        if (Math.min(r1, r2) * Math.min(r1,r2) * Math.PI <= overlap + SMALL$1) {\n\t            return Math.abs(r1 - r2);\n\t        }\n\t\n\t        return bisect(function(distance) {\n\t            return circleOverlap(r1, r2, distance) - overlap;\n\t        }, 0, r1 + r2);\n\t    }\n\t\n\t    /** Missing pair-wise intersection area data can cause problems:\n\t     treating as an unknown means that sets will be laid out overlapping,\n\t     which isn't what people expect. To reflect that we want disjoint sets\n\t     here, set the overlap to 0 for all missing pairwise set intersections */\n\t    function addMissingAreas(areas) {\n\t        areas = areas.slice();\n\t\n\t        // two circle intersections that aren't defined\n\t        var ids = [], pairs = {}, i, j, a, b;\n\t        for (i = 0; i < areas.length; ++i) {\n\t            var area = areas[i];\n\t            if (area.sets.length == 1) {\n\t                ids.push(area.sets[0]);\n\t            } else if (area.sets.length == 2) {\n\t                a = area.sets[0];\n\t                b = area.sets[1];\n\t                pairs[[a, b]] = true;\n\t                pairs[[b, a]] = true;\n\t            }\n\t        }\n\t        ids.sort(function(a, b) { return a > b; });\n\t\n\t        for (i = 0; i < ids.length; ++i) {\n\t            a = ids[i];\n\t            for (j = i + 1; j < ids.length; ++j) {\n\t                b = ids[j];\n\t                if (!([a, b] in pairs)) {\n\t                    areas.push({'sets': [a, b],\n\t                                'size': 0});\n\t                }\n\t            }\n\t        }\n\t        return areas;\n\t    }\n\t\n\t    /// Returns two matrices, one of the euclidean distances between the sets\n\t    /// and the other indicating if there are subset or disjoint set relationships\n\t    function getDistanceMatrices(areas, sets, setids) {\n\t        // initialize an empty distance matrix between all the points\n\t        var distances = zerosM(sets.length, sets.length),\n\t            constraints = zerosM(sets.length, sets.length);\n\t\n\t        // compute required distances between all the sets such that\n\t        // the areas match\n\t        areas.filter(function(x) { return x.sets.length == 2; })\n\t            .map(function(current) {\n\t            var left = setids[current.sets[0]],\n\t                right = setids[current.sets[1]],\n\t                r1 = Math.sqrt(sets[left].size / Math.PI),\n\t                r2 = Math.sqrt(sets[right].size / Math.PI),\n\t                distance = distanceFromIntersectArea(r1, r2, current.size);\n\t\n\t            distances[left][right] = distances[right][left] = distance;\n\t\n\t            // also update constraints to indicate if its a subset or disjoint\n\t            // relationship\n\t            var c = 0;\n\t            if (current.size + 1e-10 >= Math.min(sets[left].size,\n\t                                                 sets[right].size)) {\n\t                c = 1;\n\t            } else if (current.size <= 1e-10) {\n\t                c = -1;\n\t            }\n\t            constraints[left][right] = constraints[right][left] = c;\n\t        });\n\t\n\t        return {distances: distances, constraints: constraints};\n\t    }\n\t\n\t    /// computes the gradient and loss simulatenously for our constrained MDS optimizer\n\t    function constrainedMDSGradient(x, fxprime, distances, constraints) {\n\t        var loss = 0, i;\n\t        for (i = 0; i < fxprime.length; ++i) {\n\t            fxprime[i] = 0;\n\t        }\n\t\n\t        for (i = 0; i < distances.length; ++i) {\n\t            var xi = x[2 * i], yi = x[2 * i + 1];\n\t            for (var j = i + 1; j < distances.length; ++j) {\n\t                var xj = x[2 * j], yj = x[2 * j + 1],\n\t                    dij = distances[i][j],\n\t                    constraint = constraints[i][j];\n\t\n\t                var squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi),\n\t                    distance = Math.sqrt(squaredDistance),\n\t                    delta = squaredDistance - dij * dij;\n\t\n\t                if (((constraint > 0) && (distance <= dij)) ||\n\t                    ((constraint < 0) && (distance >= dij))) {\n\t                    continue;\n\t                }\n\t\n\t                loss += 2 * delta * delta;\n\t\n\t                fxprime[2*i]     += 4 * delta * (xi - xj);\n\t                fxprime[2*i + 1] += 4 * delta * (yi - yj);\n\t\n\t                fxprime[2*j]     += 4 * delta * (xj - xi);\n\t                fxprime[2*j + 1] += 4 * delta * (yj - yi);\n\t            }\n\t        }\n\t        return loss;\n\t    }\n\t\n\t    /// takes the best working variant of either constrained MDS or greedy\n\t    function bestInitialLayout(areas, params) {\n\t        var initial = greedyLayout(areas, params);\n\t\n\t        // greedylayout is sufficient for all 2/3 circle cases. try out\n\t        // constrained MDS for higher order problems, take its output\n\t        // if it outperforms. (greedy is aesthetically better on 2/3 circles\n\t        // since it axis aligns)\n\t        if (areas.length >= 8) {\n\t            var constrained  = constrainedMDSLayout(areas, params),\n\t                constrainedLoss = lossFunction(constrained, areas),\n\t                greedyLoss = lossFunction(initial, areas);\n\t\n\t            if (constrainedLoss + 1e-8 < greedyLoss) {\n\t                initial = constrained;\n\t            }\n\t        }\n\t        return initial;\n\t    }\n\t\n\t    /// use the constrained MDS variant to generate an initial layout\n\t    function constrainedMDSLayout(areas, params) {\n\t        params = params || {};\n\t        var restarts = params.restarts || 10;\n\t\n\t        // bidirectionally map sets to a rowid  (so we can create a matrix)\n\t        var sets = [], setids = {}, i;\n\t        for (i = 0; i < areas.length; ++i ) {\n\t            var area = areas[i];\n\t            if (area.sets.length == 1) {\n\t                setids[area.sets[0]] = sets.length;\n\t                sets.push(area);\n\t            }\n\t        }\n\t\n\t        var matrices = getDistanceMatrices(areas, sets, setids),\n\t            distances = matrices.distances,\n\t            constraints = matrices.constraints;\n\t\n\t        // keep distances bounded, things get messed up otherwise.\n\t        // TODO: proper preconditioner?\n\t        var norm = norm2(distances.map(norm2))/(distances.length);\n\t        distances = distances.map(function (row) {\n\t            return row.map(function (value) { return value / norm; });});\n\t\n\t        var obj = function(x, fxprime) {\n\t            return constrainedMDSGradient(x, fxprime, distances, constraints);\n\t        };\n\t\n\t        var best, current;\n\t        for (i = 0; i < restarts; ++i) {\n\t            var initial = zeros(distances.length*2).map(Math.random);\n\t\n\t            current = minimizeConjugateGradient(obj, initial, params);\n\t            if (!best || (current.fx < best.fx)) {\n\t                best = current;\n\t            }\n\t        }\n\t        var positions = best.x;\n\t\n\t        // translate rows back to (x,y,radius) coordinates\n\t        var circles = {};\n\t        for (i = 0; i < sets.length; ++i) {\n\t            var set = sets[i];\n\t            circles[set.sets[0]] = {\n\t                x: positions[2*i] * norm,\n\t                y: positions[2*i + 1] * norm,\n\t                radius:  Math.sqrt(set.size / Math.PI)\n\t            };\n\t        }\n\t\n\t        if (params.history) {\n\t            for (i = 0; i < params.history.length; ++i) {\n\t                multiplyBy(params.history[i].x, norm);\n\t            }\n\t        }\n\t        return circles;\n\t    }\n\t\n\t    /** Lays out a Venn diagram greedily, going from most overlapped sets to\n\t    least overlapped, attempting to position each new set such that the\n\t    overlapping areas to already positioned sets are basically right */\n\t    function greedyLayout(areas) {\n\t        // define a circle for each set\n\t        var circles = {}, setOverlaps = {}, set;\n\t        for (var i = 0; i < areas.length; ++i) {\n\t            var area = areas[i];\n\t            if (area.sets.length == 1) {\n\t                set = area.sets[0];\n\t                circles[set] = {x: 1e10, y: 1e10,\n\t                                rowid: circles.length,\n\t                                size: area.size,\n\t                                radius: Math.sqrt(area.size / Math.PI)};\n\t                setOverlaps[set] = [];\n\t            }\n\t        }\n\t        areas = areas.filter(function(a) { return a.sets.length == 2; });\n\t\n\t        // map each set to a list of all the other sets that overlap it\n\t        for (i = 0; i < areas.length; ++i) {\n\t            var current = areas[i];\n\t            var weight = current.hasOwnProperty('weight') ? current.weight : 1.0;\n\t            var left = current.sets[0], right = current.sets[1];\n\t\n\t            // completely overlapped circles shouldn't be positioned early here\n\t            if (current.size + SMALL$1 >= Math.min(circles[left].size,\n\t                                                 circles[right].size)) {\n\t                weight = 0;\n\t            }\n\t\n\t            setOverlaps[left].push ({set:right, size:current.size, weight:weight});\n\t            setOverlaps[right].push({set:left,  size:current.size, weight:weight});\n\t        }\n\t\n\t        // get list of most overlapped sets\n\t        var mostOverlapped = [];\n\t        for (set in setOverlaps) {\n\t            if (setOverlaps.hasOwnProperty(set)) {\n\t                var size = 0;\n\t                for (i = 0; i < setOverlaps[set].length; ++i) {\n\t                    size += setOverlaps[set][i].size * setOverlaps[set][i].weight;\n\t                }\n\t\n\t                mostOverlapped.push({set: set, size:size});\n\t            }\n\t        }\n\t\n\t        // sort by size desc\n\t        function sortOrder(a,b) {\n\t            return b.size - a.size;\n\t        }\n\t        mostOverlapped.sort(sortOrder);\n\t\n\t        // keep track of what sets have been laid out\n\t        var positioned = {};\n\t        function isPositioned(element) {\n\t            return element.set in positioned;\n\t        }\n\t\n\t        // adds a point to the output\n\t        function positionSet(point, index) {\n\t            circles[index].x = point.x;\n\t            circles[index].y = point.y;\n\t            positioned[index] = true;\n\t        }\n\t\n\t        // add most overlapped set at (0,0)\n\t        positionSet({x: 0, y: 0}, mostOverlapped[0].set);\n\t\n\t        // get distances between all points. TODO, necessary?\n\t        // answer: probably not\n\t        // var distances = venn.getDistanceMatrices(circles, areas).distances;\n\t        for (i = 1; i < mostOverlapped.length; ++i) {\n\t            var setIndex = mostOverlapped[i].set,\n\t                overlap = setOverlaps[setIndex].filter(isPositioned);\n\t            set = circles[setIndex];\n\t            overlap.sort(sortOrder);\n\t\n\t            if (overlap.length === 0) {\n\t                // this shouldn't happen anymore with addMissingAreas\n\t                throw \"ERROR: missing pairwise overlap information\";\n\t            }\n\t\n\t            var points = [];\n\t            for (var j = 0; j < overlap.length; ++j) {\n\t                // get appropriate distance from most overlapped already added set\n\t                var p1 = circles[overlap[j].set],\n\t                    d1 = distanceFromIntersectArea(set.radius, p1.radius,\n\t                                                   overlap[j].size);\n\t\n\t                // sample positions at 90 degrees for maximum aesthetics\n\t                points.push({x : p1.x + d1, y : p1.y});\n\t                points.push({x : p1.x - d1, y : p1.y});\n\t                points.push({y : p1.y + d1, x : p1.x});\n\t                points.push({y : p1.y - d1, x : p1.x});\n\t\n\t                // if we have at least 2 overlaps, then figure out where the\n\t                // set should be positioned analytically and try those too\n\t                for (var k = j + 1; k < overlap.length; ++k) {\n\t                    var p2 = circles[overlap[k].set],\n\t                        d2 = distanceFromIntersectArea(set.radius, p2.radius,\n\t                                                       overlap[k].size);\n\t\n\t                    var extraPoints = circleCircleIntersection(\n\t                        { x: p1.x, y: p1.y, radius: d1},\n\t                        { x: p2.x, y: p2.y, radius: d2});\n\t\n\t                    for (var l = 0; l < extraPoints.length; ++l) {\n\t                        points.push(extraPoints[l]);\n\t                    }\n\t                }\n\t            }\n\t\n\t            // we have some candidate positions for the set, examine loss\n\t            // at each position to figure out where to put it at\n\t            var bestLoss = 1e50, bestPoint = points[0];\n\t            for (j = 0; j < points.length; ++j) {\n\t                circles[setIndex].x = points[j].x;\n\t                circles[setIndex].y = points[j].y;\n\t                var loss = lossFunction(circles, areas);\n\t                if (loss < bestLoss) {\n\t                    bestLoss = loss;\n\t                    bestPoint = points[j];\n\t                }\n\t            }\n\t\n\t            positionSet(bestPoint, setIndex);\n\t        }\n\t\n\t        return circles;\n\t    }\n\t\n\t    /** Given a bunch of sets, and the desired overlaps between these sets - computes\n\t    the distance from the actual overlaps to the desired overlaps. Note that\n\t    this method ignores overlaps of more than 2 circles */\n\t    function lossFunction(sets, overlaps) {\n\t        var output = 0;\n\t\n\t        function getCircles(indices) {\n\t            return indices.map(function(i) { return sets[i]; });\n\t        }\n\t\n\t        for (var i = 0; i < overlaps.length; ++i) {\n\t            var area = overlaps[i], overlap;\n\t            if (area.sets.length == 1) {\n\t                continue;\n\t            } else if (area.sets.length == 2) {\n\t                var left = sets[area.sets[0]],\n\t                    right = sets[area.sets[1]];\n\t                overlap = circleOverlap(left.radius, right.radius,\n\t                                        distance(left, right));\n\t            } else {\n\t                overlap = intersectionArea(getCircles(area.sets));\n\t            }\n\t\n\t            var weight = area.hasOwnProperty('weight') ? area.weight : 1.0;\n\t            output += weight * (overlap - area.size) * (overlap - area.size);\n\t        }\n\t\n\t        return output;\n\t    }\n\t\n\t    // orientates a bunch of circles to point in orientation\n\t    function orientateCircles(circles, orientation, orientationOrder) {\n\t        if (orientationOrder === null) {\n\t            circles.sort(function (a, b) { return b.radius - a.radius; });\n\t        } else {\n\t            circles.sort(orientationOrder);\n\t        }\n\t\n\t        var i;\n\t        // shift circles so largest circle is at (0, 0)\n\t        if (circles.length > 0) {\n\t            var largestX = circles[0].x,\n\t                largestY = circles[0].y;\n\t\n\t            for (i = 0; i < circles.length; ++i) {\n\t                circles[i].x -= largestX;\n\t                circles[i].y -= largestY;\n\t            }\n\t        }\n\t\n\t        // rotate circles so that second largest is at an angle of 'orientation'\n\t        // from largest\n\t        if (circles.length > 1) {\n\t            var rotation = Math.atan2(circles[1].x, circles[1].y) - orientation,\n\t                c = Math.cos(rotation),\n\t                s = Math.sin(rotation), x, y;\n\t\n\t            for (i = 0; i < circles.length; ++i) {\n\t                x = circles[i].x;\n\t                y = circles[i].y;\n\t                circles[i].x = c * x - s * y;\n\t                circles[i].y = s * x + c * y;\n\t            }\n\t        }\n\t\n\t        // mirror solution if third solution is above plane specified by\n\t        // first two circles\n\t        if (circles.length > 2) {\n\t            var angle = Math.atan2(circles[2].x, circles[2].y) - orientation;\n\t            while (angle < 0) { angle += 2* Math.PI; }\n\t            while (angle > 2*Math.PI) { angle -= 2* Math.PI; }\n\t            if (angle > Math.PI) {\n\t                var slope = circles[1].y / (1e-10 + circles[1].x);\n\t                for (i = 0; i < circles.length; ++i) {\n\t                    var d = (circles[i].x + slope * circles[i].y) / (1 + slope*slope);\n\t                    circles[i].x = 2 * d - circles[i].x;\n\t                    circles[i].y = 2 * d * slope - circles[i].y;\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    function disjointCluster(circles) {\n\t        // union-find clustering to get disjoint sets\n\t        circles.map(function(circle) { circle.parent = circle; });\n\t\n\t        // path compression step in union find\n\t        function find(circle) {\n\t            if (circle.parent !== circle) {\n\t                circle.parent = find(circle.parent);\n\t            }\n\t            return circle.parent;\n\t        }\n\t\n\t        function union(x, y) {\n\t            var xRoot = find(x), yRoot = find(y);\n\t            xRoot.parent = yRoot;\n\t        }\n\t\n\t        // get the union of all overlapping sets\n\t        for (var i = 0; i < circles.length; ++i) {\n\t            for (var j = i + 1; j < circles.length; ++j) {\n\t                var maxDistance = circles[i].radius + circles[j].radius;\n\t                if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {\n\t                    union(circles[j], circles[i]);\n\t                }\n\t            }\n\t        }\n\t\n\t        // find all the disjoint clusters and group them together\n\t        var disjointClusters = {}, setid;\n\t        for (i = 0; i < circles.length; ++i) {\n\t            setid = find(circles[i]).parent.setid;\n\t            if (!(setid in disjointClusters)) {\n\t                disjointClusters[setid] = [];\n\t            }\n\t            disjointClusters[setid].push(circles[i]);\n\t        }\n\t\n\t        // cleanup bookkeeping\n\t        circles.map(function(circle) { delete circle.parent; });\n\t\n\t        // return in more usable form\n\t        var ret = [];\n\t        for (setid in disjointClusters) {\n\t            if (disjointClusters.hasOwnProperty(setid)) {\n\t                ret.push(disjointClusters[setid]);\n\t            }\n\t        }\n\t        return ret;\n\t    }\n\t\n\t    function getBoundingBox(circles) {\n\t        var minMax = function(d) {\n\t            var hi = Math.max.apply(null, circles.map(\n\t                                    function(c) { return c[d] + c.radius; } )),\n\t                lo = Math.min.apply(null, circles.map(\n\t                                    function(c) { return c[d] - c.radius;} ));\n\t            return {max:hi, min:lo};\n\t        };\n\t\n\t        return {xRange: minMax('x'), yRange: minMax('y')};\n\t    }\n\t\n\t    function normalizeSolution(solution, orientation, orientationOrder) {\n\t        if (orientation === null){\n\t            orientation = Math.PI/2;\n\t        }\n\t\n\t        // work with a list instead of a dictionary, and take a copy so we\n\t        // don't mutate input\n\t        var circles = [], i, setid;\n\t        for (setid in solution) {\n\t            if (solution.hasOwnProperty(setid)) {\n\t                var previous = solution[setid];\n\t                circles.push({x: previous.x,\n\t                              y: previous.y,\n\t                              radius: previous.radius,\n\t                              setid: setid});\n\t            }\n\t        }\n\t\n\t        // get all the disjoint clusters\n\t        var clusters = disjointCluster(circles);\n\t\n\t        // orientate all disjoint sets, get sizes\n\t        for (i = 0; i < clusters.length; ++i) {\n\t            orientateCircles(clusters[i], orientation, orientationOrder);\n\t            var bounds = getBoundingBox(clusters[i]);\n\t            clusters[i].size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);\n\t            clusters[i].bounds = bounds;\n\t        }\n\t        clusters.sort(function(a, b) { return b.size - a.size; });\n\t\n\t        // orientate the largest at 0,0, and get the bounds\n\t        circles = clusters[0];\n\t        var returnBounds = circles.bounds;\n\t\n\t        var spacing = (returnBounds.xRange.max - returnBounds.xRange.min)/50;\n\t\n\t        function addCluster(cluster, right, bottom) {\n\t            if (!cluster) return;\n\t\n\t            var bounds = cluster.bounds, xOffset, yOffset, centreing;\n\t\n\t            if (right) {\n\t                xOffset = returnBounds.xRange.max  - bounds.xRange.min + spacing;\n\t            } else {\n\t                xOffset = returnBounds.xRange.max  - bounds.xRange.max;\n\t                centreing = (bounds.xRange.max - bounds.xRange.min) / 2 -\n\t                            (returnBounds.xRange.max - returnBounds.xRange.min) / 2;\n\t                if (centreing < 0) xOffset += centreing;\n\t            }\n\t\n\t            if (bottom) {\n\t                yOffset = returnBounds.yRange.max  - bounds.yRange.min + spacing;\n\t            } else {\n\t                yOffset = returnBounds.yRange.max  - bounds.yRange.max;\n\t                centreing = (bounds.yRange.max - bounds.yRange.min) / 2 -\n\t                            (returnBounds.yRange.max - returnBounds.yRange.min) / 2;\n\t                if (centreing < 0) yOffset += centreing;\n\t            }\n\t\n\t            for (var j = 0; j < cluster.length; ++j) {\n\t                cluster[j].x += xOffset;\n\t                cluster[j].y += yOffset;\n\t                circles.push(cluster[j]);\n\t            }\n\t        }\n\t\n\t        var index = 1;\n\t        while (index < clusters.length) {\n\t            addCluster(clusters[index], true, false);\n\t            addCluster(clusters[index+1], false, true);\n\t            addCluster(clusters[index+2], true, true);\n\t            index += 3;\n\t\n\t            // have one cluster (in top left). lay out next three relative\n\t            // to it in a grid\n\t            returnBounds = getBoundingBox(circles);\n\t        }\n\t\n\t        // convert back to solution form\n\t        var ret = {};\n\t        for (i = 0; i < circles.length; ++i) {\n\t            ret[circles[i].setid] = circles[i];\n\t        }\n\t        return ret;\n\t    }\n\t\n\t    /** Scales a solution from venn.venn or venn.greedyLayout such that it fits in\n\t    a rectangle of width/height - with padding around the borders. also\n\t    centers the diagram in the available space at the same time */\n\t    function scaleSolution(solution, width, height, padding) {\n\t        var circles = [], setids = [];\n\t        for (var setid in solution) {\n\t            if (solution.hasOwnProperty(setid)) {\n\t                setids.push(setid);\n\t                circles.push(solution[setid]);\n\t            }\n\t        }\n\t\n\t        width -= 2*padding;\n\t        height -= 2*padding;\n\t\n\t        var bounds = getBoundingBox(circles),\n\t            xRange = bounds.xRange,\n\t            yRange = bounds.yRange,\n\t            xScaling = width  / (xRange.max - xRange.min),\n\t            yScaling = height / (yRange.max - yRange.min),\n\t            scaling = Math.min(yScaling, xScaling),\n\t\n\t            // while we're at it, center the diagram too\n\t            xOffset = (width -  (xRange.max - xRange.min) * scaling) / 2,\n\t            yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;\n\t\n\t        var scaled = {};\n\t        for (var i = 0; i < circles.length; ++i) {\n\t            var circle = circles[i];\n\t            scaled[setids[i]] = {\n\t                radius: scaling * circle.radius,\n\t                x: padding + xOffset + (circle.x - xRange.min) * scaling,\n\t                y: padding + yOffset + (circle.y - yRange.min) * scaling,\n\t            };\n\t        }\n\t\n\t        return scaled;\n\t    }\n\t\n\t    /*global console:true*/\n\t\n\t    function VennDiagram() {\n\t        var width = 600,\n\t            height = 350,\n\t            padding = 15,\n\t            duration = 1000,\n\t            orientation = Math.PI / 2,\n\t            normalize = true,\n\t            wrap = true,\n\t            styled = true,\n\t            fontSize = null,\n\t            orientationOrder = null,\n\t\n\t            // mimic the behaviour of d3.scale.category10 from the previous\n\t            // version of d3\n\t            colourMap = {},\n\t\n\t            // so this is the same as d3.schemeCategory10, which is only defined in d3 4.0\n\t            // since we can support older versions of d3 as long as we don't force this,\n\t            // I'm hackily redefining below. TODO: remove this and change to d3.schemeCategory10\n\t            colourScheme = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\", \"#e377c2\", \"#7f7f7f\", \"#bcbd22\", \"#17becf\"],\n\t            colourIndex = 0,\n\t            colours = function(key) {\n\t                if (key in colourMap) {\n\t                    return colourMap[key];\n\t                }\n\t                var ret = colourMap[key] = colourScheme[colourIndex];\n\t                colourIndex += 1;\n\t                if (colourIndex >= colourScheme.length) {\n\t                    colourIndex = 0;\n\t                }\n\t                return ret;\n\t            },\n\t            layoutFunction = venn;\n\t\n\t        function chart(selection) {\n\t            var data = selection.datum();\n\t            var solution = layoutFunction(data);\n\t            if (normalize) {\n\t                solution = normalizeSolution(solution,\n\t                                             orientation,\n\t                                             orientationOrder);\n\t            }\n\t            var circles = scaleSolution(solution, width, height, padding);\n\t            var textCentres = computeTextCentres(circles, data);\n\t\n\t            // create svg if not already existing\n\t            selection.selectAll(\"svg\").data([circles]).enter().append(\"svg\");\n\t\n\t            var svg = selection.select(\"svg\")\n\t                .attr(\"width\", width)\n\t                .attr(\"height\", height);\n\t\n\t            // to properly transition intersection areas, we need the\n\t            // previous circles locations. load from elements\n\t            var previous = {}, hasPrevious = false;\n\t            svg.selectAll(\"g path\").each(function (d) {\n\t                var path = d3.select(this).attr(\"d\");\n\t                if ((d.sets.length == 1) && path) {\n\t                    hasPrevious = true;\n\t                    previous[d.sets[0]] = circleFromPath(path);\n\t                }\n\t            });\n\t\n\t            // interpolate intersection area paths between previous and\n\t            // current paths\n\t            var pathTween = function(d) {\n\t                return function(t) {\n\t                    var c = d.sets.map(function(set) {\n\t                        var start = previous[set], end = circles[set];\n\t                        if (!start) {\n\t                            start = {x : width/2, y : height/2, radius : 1};\n\t                        }\n\t                        if (!end) {\n\t                            end = {x : width/2, y : height/2, radius : 1};\n\t                        }\n\t                        return {'x' : start.x * (1 - t) + end.x * t,\n\t                                'y' : start.y * (1 - t) + end.y * t,\n\t                                'radius' : start.radius * (1 - t) + end.radius * t};\n\t                    });\n\t                    return intersectionAreaPath(c);\n\t                };\n\t            };\n\t\n\t            // update data, joining on the set ids\n\t            var nodes = svg.selectAll(\"g\")\n\t                .data(data, function(d) { return d.sets; });\n\t\n\t            // create new nodes\n\t            var enter = nodes.enter()\n\t                .append('g')\n\t                .attr(\"class\", function(d) {\n\t                    return \"venn-area venn-\" +\n\t                        (d.sets.length == 1 ? \"circle\" : \"intersection\");\n\t                })\n\t                .attr(\"data-venn-sets\", function(d) {\n\t                    return d.sets.join(\"_\");\n\t                });\n\t\n\t            var enterPath = enter.append(\"path\"),\n\t                enterText = enter.append(\"text\")\n\t                .attr(\"class\", \"label\")\n\t                .text(function (d) { return label(d); } )\n\t                .attr(\"text-anchor\", \"middle\")\n\t                .attr(\"dy\", \".35em\")\n\t                .attr(\"x\", width/2)\n\t                .attr(\"y\", height/2);\n\t\n\t\n\t            // apply minimal style if wanted\n\t            if (styled) {\n\t                enterPath.style(\"fill-opacity\", \"0\")\n\t                    .filter(function (d) { return d.sets.length == 1; } )\n\t                    .style(\"fill\", function(d) { return colours(label(d)); })\n\t                    .style(\"fill-opacity\", \".25\");\n\t\n\t                enterText\n\t                    .style(\"fill\", function(d) { return d.sets.length == 1 ? colours(label(d)) : \"#444\"; });\n\t            }\n\t\n\t            // update existing, using pathTween if necessary\n\t            var update = selection;\n\t            if (hasPrevious) {\n\t                update = selection.transition(\"venn\").duration(duration);\n\t                update.selectAll(\"path\")\n\t                    .attrTween(\"d\", pathTween);\n\t            } else {\n\t                update.selectAll(\"path\")\n\t                    .attr(\"d\", function(d) {\n\t                        return intersectionAreaPath(d.sets.map(function (set) { return circles[set]; }));\n\t                    });\n\t            }\n\t\n\t            var updateText = update.selectAll(\"text\")\n\t                .filter(function (d) { return d.sets in textCentres; })\n\t                .text(function (d) { return label(d); } )\n\t                .attr(\"x\", function(d) { return Math.floor(textCentres[d.sets].x);})\n\t                .attr(\"y\", function(d) { return Math.floor(textCentres[d.sets].y);});\n\t\n\t            if (wrap) {\n\t                if (hasPrevious) {\n\t                    // d3 4.0 uses 'on' for events on transitions,\n\t                    // but d3 3.0 used 'each' instead. switch appropiately\n\t                    if ('on' in updateText) {\n\t                        updateText.on(\"end\", wrapText(circles, label));\n\t                    } else {\n\t                        updateText.each(\"end\", wrapText(circles, label));\n\t                    }\n\t                } else {\n\t                    updateText.each(wrapText(circles, label));\n\t                }\n\t            }\n\t\n\t            // remove old\n\t            var exit = nodes.exit().transition('venn').duration(duration).remove();\n\t            exit.selectAll(\"path\")\n\t                .attrTween(\"d\", pathTween);\n\t\n\t            var exitText = exit.selectAll(\"text\")\n\t                .attr(\"x\", width/2)\n\t                .attr(\"y\", height/2);\n\t\n\t            // if we've been passed a fontSize explicitly, use it to\n\t            // transition\n\t            if (fontSize !== null) {\n\t                enterText.style(\"font-size\", \"0px\");\n\t                updateText.style(\"font-size\", fontSize);\n\t                exitText.style(\"font-size\", \"0px\");\n\t            }\n\t\n\t\n\t            return {'circles': circles,\n\t                    'textCentres': textCentres,\n\t                    'nodes': nodes,\n\t                    'enter': enter,\n\t                    'update': update,\n\t                    'exit': exit};\n\t        }\n\t\n\t        function label(d) {\n\t            if (d.label) {\n\t                return d.label;\n\t            }\n\t            if (d.sets.length == 1) {\n\t                return '' + d.sets[0];\n\t            }\n\t        }\n\t\n\t        chart.wrap = function(_) {\n\t            if (!arguments.length) return wrap;\n\t            wrap = _;\n\t            return chart;\n\t        };\n\t\n\t        chart.width = function(_) {\n\t            if (!arguments.length) return width;\n\t            width = _;\n\t            return chart;\n\t        };\n\t\n\t        chart.height = function(_) {\n\t            if (!arguments.length) return height;\n\t            height = _;\n\t            return chart;\n\t        };\n\t\n\t        chart.padding = function(_) {\n\t            if (!arguments.length) return padding;\n\t            padding = _;\n\t            return chart;\n\t        };\n\t\n\t        chart.colours = function(_) {\n\t            if (!arguments.length) return colours;\n\t            colours = _;\n\t            return chart;\n\t        };\n\t\n\t        chart.fontSize = function(_) {\n\t            if (!arguments.length) return fontSize;\n\t            fontSize = _;\n\t            return chart;\n\t        };\n\t\n\t        chart.duration = function(_) {\n\t            if (!arguments.length) return duration;\n\t            duration = _;\n\t            return chart;\n\t        };\n\t\n\t        chart.layoutFunction = function(_) {\n\t            if (!arguments.length) return layoutFunction;\n\t            layoutFunction = _;\n\t            return chart;\n\t        };\n\t\n\t        chart.normalize = function(_) {\n\t            if (!arguments.length) return normalize;\n\t            normalize = _;\n\t            return chart;\n\t        };\n\t\n\t        chart.styled = function(_) {\n\t            if (!arguments.length) return styled;\n\t            styled = _;\n\t            return chart;\n\t        };\n\t\n\t        chart.orientation = function(_) {\n\t            if (!arguments.length) return orientation;\n\t            orientation = _;\n\t            return chart;\n\t        };\n\t\n\t        chart.orientationOrder = function(_) {\n\t            if (!arguments.length) return orientationOrder;\n\t            orientationOrder = _;\n\t            return chart;\n\t        };\n\t\n\t        return chart;\n\t    }\n\t    // sometimes text doesn't fit inside the circle, if thats the case lets wrap\n\t    // the text here such that it fits\n\t    // todo: looks like this might be merged into d3 (\n\t    // https://github.com/mbostock/d3/issues/1642),\n\t    // also worth checking out is\n\t    // http://engineering.findthebest.com/wrapping-axis-labels-in-d3-js/\n\t    // this seems to be one of those things that should be easy but isn't\n\t    function wrapText(circles, labeller) {\n\t        return function() {\n\t            var text = d3.select(this),\n\t                data = text.datum(),\n\t                width = circles[data.sets[0]].radius || 50,\n\t                label = labeller(data) || '';\n\t\n\t                var words = label.split(/\\s+/).reverse(),\n\t                maxLines = 3,\n\t                minChars = (label.length + words.length) / maxLines,\n\t                word = words.pop(),\n\t                line = [word],\n\t                joined,\n\t                lineNumber = 0,\n\t                lineHeight = 1.1, // ems\n\t                tspan = text.text(null).append(\"tspan\").text(word);\n\t\n\t            while (true) {\n\t                word = words.pop();\n\t                if (!word) break;\n\t                line.push(word);\n\t                joined = line.join(\" \");\n\t                tspan.text(joined);\n\t                if (joined.length > minChars && tspan.node().getComputedTextLength() > width) {\n\t                    line.pop();\n\t                    tspan.text(line.join(\" \"));\n\t                    line = [word];\n\t                    tspan = text.append(\"tspan\").text(word);\n\t                    lineNumber++;\n\t                }\n\t            }\n\t\n\t            var initial = 0.35 - lineNumber * lineHeight / 2,\n\t                x = text.attr(\"x\"),\n\t                y = text.attr(\"y\");\n\t\n\t            text.selectAll(\"tspan\")\n\t                .attr(\"x\", x)\n\t                .attr(\"y\", y)\n\t                .attr(\"dy\", function(d, i) {\n\t                     return (initial + i * lineHeight) + \"em\";\n\t                });\n\t        };\n\t    }\n\t\n\t    function circleMargin(current, interior, exterior) {\n\t        var margin = interior[0].radius - distance(interior[0], current), i, m;\n\t        for (i = 1; i < interior.length; ++i) {\n\t            m = interior[i].radius - distance(interior[i], current);\n\t            if (m <= margin) {\n\t                margin = m;\n\t            }\n\t        }\n\t\n\t        for (i = 0; i < exterior.length; ++i) {\n\t            m = distance(exterior[i], current) - exterior[i].radius;\n\t            if (m <= margin) {\n\t                margin = m;\n\t            }\n\t        }\n\t        return margin;\n\t    }\n\t\n\t    // compute the center of some circles by maximizing the margin of\n\t    // the center point relative to the circles (interior) after subtracting\n\t    // nearby circles (exterior)\n\t    function computeTextCentre(interior, exterior) {\n\t        // get an initial estimate by sampling around the interior circles\n\t        // and taking the point with the biggest margin\n\t        var points = [], i;\n\t        for (i = 0; i < interior.length; ++i) {\n\t            var c = interior[i];\n\t            points.push({x: c.x, y: c.y});\n\t            points.push({x: c.x + c.radius/2, y: c.y});\n\t            points.push({x: c.x - c.radius/2, y: c.y});\n\t            points.push({x: c.x, y: c.y + c.radius/2});\n\t            points.push({x: c.x, y: c.y - c.radius/2});\n\t        }\n\t        var initial = points[0], margin = circleMargin(points[0], interior, exterior);\n\t        for (i = 1; i < points.length; ++i) {\n\t            var m = circleMargin(points[i], interior, exterior);\n\t            if (m >= margin) {\n\t                initial = points[i];\n\t                margin = m;\n\t            }\n\t        }\n\t\n\t        // maximize the margin numerically\n\t        var solution = fmin(\n\t                    function(p) { return -1 * circleMargin({x: p[0], y: p[1]}, interior, exterior); },\n\t                    [initial.x, initial.y],\n\t                    {maxIterations:500, minErrorDelta:1e-10}).solution;\n\t        var ret = {x: solution[0], y: solution[1]};\n\t\n\t        // check solution, fallback as needed (happens if fully overlapped\n\t        // etc)\n\t        var valid = true;\n\t        for (i = 0; i < interior.length; ++i) {\n\t            if (distance(ret, interior[i]) > interior[i].radius) {\n\t                valid = false;\n\t                break;\n\t            }\n\t        }\n\t\n\t        for (i = 0; i < exterior.length; ++i) {\n\t            if (distance(ret, exterior[i]) < exterior[i].radius) {\n\t                valid = false;\n\t                break;\n\t            }\n\t        }\n\t\n\t        if (!valid) {\n\t            if (interior.length == 1) {\n\t                ret = {x: interior[0].x, y: interior[0].y};\n\t            } else {\n\t                var areaStats = {};\n\t                intersectionArea(interior, areaStats);\n\t\n\t                if (areaStats.arcs.length === 0) {\n\t                    ret = {'x': 0, 'y': -1000, disjoint:true};\n\t\n\t                } else if (areaStats.arcs.length == 1) {\n\t                    ret = {'x': areaStats.arcs[0].circle.x,\n\t                           'y': areaStats.arcs[0].circle.y};\n\t\n\t                } else if (exterior.length) {\n\t                    // try again without other circles\n\t                    ret = computeTextCentre(interior, []);\n\t\n\t                } else {\n\t                    // take average of all the points in the intersection\n\t                    // polygon. this should basically never happen\n\t                    // and has some issues:\n\t                    // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n\t                    ret = getCenter(areaStats.arcs.map(function (a) { return a.p1; }));\n\t                }\n\t            }\n\t        }\n\t\n\t        return ret;\n\t    }\n\t\n\t    // given a dictionary of {setid : circle}, returns\n\t    // a dictionary of setid to list of circles that completely overlap it\n\t    function getOverlappingCircles(circles) {\n\t        var ret = {}, circleids = [];\n\t        for (var circleid in circles) {\n\t            circleids.push(circleid);\n\t            ret[circleid] = [];\n\t        }\n\t        for (var i  = 0; i < circleids.length; i++) {\n\t            var a = circles[circleids[i]];\n\t            for (var j = i + 1; j < circleids.length; ++j) {\n\t                var b = circles[circleids[j]],\n\t                    d = distance(a, b);\n\t\n\t                if (d + b.radius <= a.radius + 1e-10) {\n\t                    ret[circleids[j]].push(circleids[i]);\n\t\n\t                } else if (d + a.radius <= b.radius + 1e-10) {\n\t                    ret[circleids[i]].push(circleids[j]);\n\t                }\n\t            }\n\t        }\n\t        return ret;\n\t    }\n\t\n\t    function computeTextCentres(circles, areas) {\n\t        var ret = {}, overlapped = getOverlappingCircles(circles);\n\t        for (var i = 0; i < areas.length; ++i) {\n\t            var area = areas[i].sets, areaids = {}, exclude = {};\n\t            for (var j = 0; j < area.length; ++j) {\n\t                areaids[area[j]] = true;\n\t                var overlaps = overlapped[area[j]];\n\t                // keep track of any circles that overlap this area,\n\t                // and don't consider for purposes of computing the text\n\t                // centre\n\t                for (var k = 0; k < overlaps.length; ++k) {\n\t                    exclude[overlaps[k]] = true;\n\t                }\n\t            }\n\t\n\t            var interior = [], exterior = [];\n\t            for (var setid in circles) {\n\t                if (setid in areaids) {\n\t                    interior.push(circles[setid]);\n\t                } else if (!(setid in exclude)) {\n\t                    exterior.push(circles[setid]);\n\t                }\n\t            }\n\t            var centre = computeTextCentre(interior, exterior);\n\t            ret[area] = centre;\n\t            if (centre.disjoint && (areas[i].size > 0)) {\n\t                console.log(\"WARNING: area \" + area + \" not represented on screen\");\n\t            }\n\t        }\n\t        return  ret;\n\t    }\n\t\n\t    // sorts all areas in the venn diagram, so that\n\t    // a particular area is on top (relativeTo) - and\n\t    // all other areas are so that the smallest areas are on top\n\t    function sortAreas(div, relativeTo) {\n\t\n\t        // figure out sets that are completly overlapped by relativeTo\n\t        var overlaps = getOverlappingCircles(div.selectAll(\"svg\").datum());\n\t        var exclude = {};\n\t        for (var i = 0; i < relativeTo.sets.length; ++i) {\n\t            var check = relativeTo.sets[i];\n\t            for (var setid in overlaps) {\n\t                var overlap = overlaps[setid];\n\t                for (var j = 0; j < overlap.length; ++j) {\n\t                    if (overlap[j] == check) {\n\t                        exclude[setid] = true;\n\t                        break;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        // checks that all sets are in exclude;\n\t        function shouldExclude(sets) {\n\t            for (var i = 0; i < sets.length; ++i) {\n\t                if (!(sets[i] in exclude)) {\n\t                    return false;\n\t                }\n\t            }\n\t            return true;\n\t        }\n\t\n\t        // need to sort div's so that Z order is correct\n\t        div.selectAll(\"g\").sort(function (a, b) {\n\t            // highest order set intersections first\n\t            if (a.sets.length != b.sets.length) {\n\t                return a.sets.length - b.sets.length;\n\t            }\n\t\n\t            if (a == relativeTo) {\n\t                return shouldExclude(b.sets) ? -1 : 1;\n\t            }\n\t            if (b == relativeTo) {\n\t                return shouldExclude(a.sets) ? 1 : -1;\n\t            }\n\t\n\t            // finally by size\n\t            return b.size - a.size;\n\t        });\n\t    }\n\t\n\t    function circlePath(x, y, r) {\n\t        var ret = [];\n\t        ret.push(\"\\nM\", x, y);\n\t        ret.push(\"\\nm\", -r, 0);\n\t        ret.push(\"\\na\", r, r, 0, 1, 0, r *2, 0);\n\t        ret.push(\"\\na\", r, r, 0, 1, 0,-r *2, 0);\n\t        return ret.join(\" \");\n\t    }\n\t\n\t    // inverse of the circlePath function, returns a circle object from an svg path\n\t    function circleFromPath(path) {\n\t        var tokens = path.split(' ');\n\t        return {'x' : parseFloat(tokens[1]),\n\t                'y' : parseFloat(tokens[2]),\n\t                'radius' : -parseFloat(tokens[4])\n\t                };\n\t    }\n\t\n\t    /** returns a svg path of the intersection area of a bunch of circles */\n\t    function intersectionAreaPath(circles) {\n\t        var stats = {};\n\t        intersectionArea(circles, stats);\n\t        var arcs = stats.arcs;\n\t\n\t        if (arcs.length === 0) {\n\t            return \"M 0 0\";\n\t\n\t        } else if (arcs.length == 1) {\n\t            var circle = arcs[0].circle;\n\t            return circlePath(circle.x, circle.y, circle.radius);\n\t\n\t        } else {\n\t            // draw path around arcs\n\t            var ret = [\"\\nM\", arcs[0].p2.x, arcs[0].p2.y];\n\t            for (var i = 0; i < arcs.length; ++i) {\n\t                var arc = arcs[i], r = arc.circle.radius, wide = arc.width > r;\n\t                ret.push(\"\\nA\", r, r, 0, wide ? 1 : 0, 1,\n\t                         arc.p1.x, arc.p1.y);\n\t            }\n\t            return ret.join(\" \");\n\t        }\n\t    }\n\t\n\t    exports.fmin = fmin;\n\t    exports.minimizeConjugateGradient = minimizeConjugateGradient;\n\t    exports.bisect = bisect;\n\t    exports.intersectionArea = intersectionArea;\n\t    exports.circleCircleIntersection = circleCircleIntersection;\n\t    exports.circleOverlap = circleOverlap;\n\t    exports.circleArea = circleArea;\n\t    exports.distance = distance;\n\t    exports.circleIntegral = circleIntegral;\n\t    exports.venn = venn;\n\t    exports.greedyLayout = greedyLayout;\n\t    exports.scaleSolution = scaleSolution;\n\t    exports.normalizeSolution = normalizeSolution;\n\t    exports.bestInitialLayout = bestInitialLayout;\n\t    exports.lossFunction = lossFunction;\n\t    exports.disjointCluster = disjointCluster;\n\t    exports.distanceFromIntersectArea = distanceFromIntersectArea;\n\t    exports.VennDiagram = VennDiagram;\n\t    exports.wrapText = wrapText;\n\t    exports.computeTextCentres = computeTextCentres;\n\t    exports.computeTextCentre = computeTextCentre;\n\t    exports.sortAreas = sortAreas;\n\t    exports.circlePath = circlePath;\n\t    exports.circleFromPath = circleFromPath;\n\t    exports.intersectionAreaPath = intersectionAreaPath;\n\t\n\t}));\n\n/***/ }\n\n/******/ })});;\n\n\n/** WEBPACK FOOTER **\n ** benfred_venn.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e3622d0033a89edad914\n **/","define( [ 'visualizations/utilities/tabular-datasets', 'plugins/benfred/venn', 'style!css!plugins/benfred/venn.css' ], function( Datasets, Venn ) {\n    return Backbone.View.extend({\n        _combinations: function( current, remaining, results ) {\n            var self = this;\n            _.each( remaining, function( value, index ) {\n                var new_current = current.slice();\n                var new_remaining = remaining.slice();\n                new_remaining.splice( 0, index + 1 );\n                new_current.push( value );\n                results.push( new_current );\n                self._combinations( new_current, new_remaining, results );\n            });\n        },\n\n        initialize: function( options ) {\n            var self = this;\n            var separator = '_';\n            Datasets.request({\n                dataset_id      : options.chart.get( 'dataset_id' ),\n                dataset_groups  : options.chart.groups,\n                success         : function( result ) {\n                    var group_keys   = [];\n                    var group_values = [];\n                    var all_values   = {};\n                    var set_size     = {};\n                    var group_ids    = [];\n                    _.each( result, function( group, i ) {\n                        var group_index = {};\n                        _.each( group.values, function( d ) {\n                            all_values[ d.observation ] = group_index[ d.observation ] = true;\n                        });\n                        group_keys.push( group.key );\n                        group_values.push( group_index );\n                        group_ids.push( i );\n                    });\n                    var combos = [];\n                    self._combinations( [], group_ids, combos );\n                    var sets = [];\n                    _.each( combos, function( c ) {\n                        var size = 0;\n                        for ( var value in all_values ) {\n                            var found = 0;\n                            _.each( c, function( group_id ) {\n                                if ( group_values[ group_id ][ value ] ) {\n                                    found++;\n                                }\n                            });\n                            if ( found == c.length ) {\n                                size++;\n                            }\n                        }\n                        if ( size > 0 ) {\n                            var set_labels = [];\n                            _.each( c, function( id ) {\n                                set_labels.push( group_keys[ id ]);\n                            });\n                            sets.push( { sets: set_labels, size: size } );\n                        }\n                    });\n                    var svg = d3.select( '#' + options.targets[ 0 ] ).datum( sets ).call( Venn.VennDiagram() );\n                    var tooltip = null;\n                    svg.selectAll( 'g' )\n                       .on( 'mouseover', function( d, i ) {\n                            Venn.sortAreas( svg, d );\n                            tooltip = d3.select( 'body' ).append( 'div' ).attr( 'class', 'venntooltip' );\n                            tooltip.transition().duration( 400 ).style( 'opacity', .9 );\n                            tooltip.text(d.size );\n                            var selection = d3.select( this ).transition( 'tooltip' ).duration( 400 );\n                            selection.select( 'path' )\n                                     .style( 'stroke-width', 3 )\n                                     .style( 'fill-opacity', d.sets.length == 1 ? .4 : .1 )\n                                     .style( 'stroke-opacity', 1 );\n                       })\n                       .on( 'mousemove', function() {\n                            tooltip.style( 'left', ( d3.event.pageX ) + 'px')\n                                   .style( 'top', ( d3.event.pageY - 28 ) + 'px');\n                       })\n                       .on( 'mouseout', function( d, i ) {\n                            tooltip.remove();\n                       });\n                    options.chart.state( 'ok', 'Venn diagram drawn.' );\n                    options.process.resolve();\n                }\n            });\n        }\n    });\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./static/repository/visualizations/benfred/venn/wrapper.js\n ** module id = 0\n ** module chunks = 20\n **/","/** Useful helper functions */\ndefine( [], function() {\n\n    /** Clone */\n    function clone( obj ) {\n        return JSON.parse( JSON.stringify( obj ) || null );\n    };\n\n    /**\n     * Check if a string is a json string\n     * @param{String}   text - Content to be validated\n     */\n    function isJSON(text) {\n        return /^[\\],:{}\\s]*$/.test(text.replace(/\\\\[\"\\\\\\/bfnrtu]/g, '@').\n            replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, ']').\n            replace(/(?:^|:|,)(?:\\s*\\[)+/g, ''));\n    };\n\n    /**\n     * Request handler for GET\n     * @param{String}   url     - Url request is made to\n     * @param{Function} success - Callback on success\n     * @param{Function} error   - Callback on error\n     * @param{Boolean}  cache   - Use cached data if available\n     */\n    function get (options) {\n        top.__utils__get__ = top.__utils__get__ || {};\n        var cache_key = JSON.stringify( options );\n        if (options.cache && top.__utils__get__[cache_key]) {\n            options.success && options.success(top.__utils__get__[cache_key]);\n            window.console.debug('utils.js::get() - Fetching from cache [' + options.url + '].');\n        } else {\n            request({\n                url     : options.url,\n                data    : options.data,\n                success : function(response) {\n                    top.__utils__get__[cache_key] = response;\n                    options.success && options.success(response);\n                },\n                error : function(response) {\n                    options.error && options.error(response);\n                }\n            });\n        }\n    };\n\n    /**\n     * Request handler\n     * @param{String}   method  - Request method ['GET', 'POST', 'DELETE', 'PUT']\n     * @param{String}   url     - Url request is made to\n     * @param{Object}   data    - Data send to url\n     * @param{Function} success - Callback on success\n     * @param{Function} error   - Callback on error\n     */\n    function request (options) {\n        var ajaxConfig = {\n            contentType : 'application/json',\n            type        : options.type || 'GET',\n            data        : options.data || {},\n            url         : options.url\n        }\n        if ( ajaxConfig.type == 'GET' || ajaxConfig.type == 'DELETE' ) {\n            if ( !$.isEmptyObject(ajaxConfig.data) ) {\n                ajaxConfig.url += ajaxConfig.url.indexOf('?') == -1 ? '?' : '&';\n                ajaxConfig.url += $.param(ajaxConfig.data, true);\n            }\n            ajaxConfig.data = null;\n        } else {\n            ajaxConfig.dataType = 'json';\n            ajaxConfig.url      = ajaxConfig.url;\n            ajaxConfig.data     = JSON.stringify( ajaxConfig.data );\n        }\n        $.ajax( ajaxConfig ).done( function( response ) {\n            if ( typeof response === 'string' && isJSON( response ) ) {\n                try {\n                    response = response.replace( 'Infinity,', '\"Infinity\",' );\n                    response = jQuery.parseJSON( response );\n                } catch ( e ) {\n                    console.debug( e );\n                }\n            }\n            options.success && options.success( response );\n        }).fail( function( response ) {\n            var response_text = null;\n            try {\n                response_text = jQuery.parseJSON( response.responseText );\n            } catch (e) {\n                response_text = response.responseText;\n            }\n            options.error && options.error( response_text, response );\n        }).always( function() {\n            options.complete && options.complete();\n        });\n    };\n\n    /**\n     * Safely merge to dictionaries\n     * @param{Object}   options         - Target dictionary\n     * @param{Object}   optionsDefault  - Source dictionary\n     */\n    function merge (options, optionsDefault) {\n        if (options) {\n            return _.defaults(options, optionsDefault);\n        } else {\n            return optionsDefault;\n        }\n    };\n\n    /** Create a unique id */\n    function uid(){\n        top.__utils__uid__ = top.__utils__uid__ || 0;\n        return 'uid-' + top.__utils__uid__++;\n    };\n\n    return {\n        get     : get,\n        merge   : merge,\n        uid     : uid,\n        request : request,\n        clone   : clone,\n        isJSON  : isJSON\n    };\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./static/repository/utilities/utils.js\n ** module id = 1\n ** module chunks = 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n **/","/** This class handles, formats and caches datasets. */\ndefine( [ 'utilities/utils' ], function( Utils ) {\n    /** Fills request dictionary with data from cache/response */\n    var _cache = {};\n    var request = function( options ) {\n        var groups      = options.dataset_groups;\n        var dataset_id  = options.dataset_id;\n        // identify columns needed to fulfill request\n        var column_list = [];\n        groups.each( function( group ) {\n            _.each( group.get( '__data_columns' ), function( column_def, column_name ) {\n                var column = group.get( column_name );\n                var block_id = _block_id( dataset_id, column );\n                if ( column_list.indexOf( column ) === -1 && !_cache[ block_id ] && column != 'auto' && column != 'zero' && column !== undefined ) {\n                    column_list.push( column );\n                }\n            });\n        });\n        if ( column_list.length == 0 ) {\n            _fillFromCache( options );\n            return;\n        }\n        // Fetch data columns into dataset object\n        Utils.get({\n            url     : Galaxy.root + 'api/datasets/' + dataset_id,\n            data    : {\n                data_type   : 'raw_data',\n                provider    : 'dataset-column',\n                indeces     : column_list.toString()\n            },\n            success : function( response ) {\n                var results = new Array( column_list.length );\n                for ( var i = 0; i < results.length; i++ ) {\n                    results[ i ] = [];\n                }\n                for ( var i in response.data ) {\n                    var row = response.data[ i ];\n                    for ( var j in row ) {\n                        var v = row[ j ];\n                        if ( v !== undefined && v != 2147483647 ) {\n                            results[ j ].push( v );\n                        }\n                    }\n                }\n                console.debug( 'tabular-datasets::_fetch() - Fetching complete.' );\n                for ( var i in results ) {\n                    var column = column_list[ i ];\n                    var block_id = _block_id( dataset_id, column );\n                    _cache[ block_id ] = results[ i ];\n                }\n                _fillFromCache( options );\n            }\n        });\n    };\n\n    /** Fill data from cache */\n    var _fillFromCache = function( options ) {\n        var groups      = options.dataset_groups;\n        var dataset_id  = options.dataset_id;\n        console.debug( 'tabular-datasets::_fillFromCache() - Filling request from cache.' );\n        var limit = 0;\n        groups.each( function( group ) {\n            _.each( group.get( '__data_columns' ), function( column_def, column_name ) {\n                var column = group.get( column_name );\n                var block_id = _block_id( dataset_id, column );\n                var column_data = _cache[ block_id ];\n                if ( column_data ) {\n                    limit = Math.max( limit, column_data.length );\n                }\n            });\n        });\n        if ( limit == 0 ) {\n            console.debug( 'tabular-datasets::_fillFromCache() - No data available.' );\n        }\n        var results = [];\n        groups.each( function( group, group_index ) {\n            var dict = Utils.merge( { key: ( group_index ) + ':' + group.get( 'key' ), values: [] }, group.attributes );\n            for ( var j = 0; j < limit; j++ ) {\n                dict.values[ j ] = { x : parseInt( j ) };\n            }\n            results.push( dict );\n        });\n        groups.each( function( group, group_index ) {\n            var values = results[ group_index ].values;\n            _.each( group.get( '__data_columns' ), function( column_def, column_name ) {\n                var column = group.get( column_name );\n                switch ( column ) {\n                    case 'auto':\n                        for ( var j = 0; j < limit; j++ ) {\n                            values[ j ][ column_name ] = parseInt( j );\n                        }\n                        break;\n                    case 'zero':\n                        for ( var j = 0; j < limit; j++ ) {\n                            values[ j ][ column_name ] = 0;\n                        }\n                        break;\n                    default:\n                        var block_id = _block_id( dataset_id, column );\n                        var column_data = _cache[ block_id ];\n                        for ( var j = 0; j < limit; j++ ) {\n                            var value = values[ j ];\n                            var v = column_data[ j ];\n                            if ( isNaN( v ) && !column_def.is_label ) {\n                                v = 0;\n                            }\n                            value[ column_name ] = v;\n                        }\n                }\n            });\n        });\n        options.success( results );\n    };\n\n    /** Get block id */\n    var _block_id = function ( dataset_id, column ) {\n        return dataset_id + '_' + '_' + column;\n    };\n\n    return { request: request };\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./static/repository/visualizations/utilities/tabular-datasets.js\n ** module id = 5\n ** module chunks = 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 24\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 6\n ** module chunks = 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0,\r\n\tstyleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the bottom of <head>.\r\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n\tvar head = getHeadElement();\r\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t}\r\n\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\thead.appendChild(styleElement);\r\n\t} else {\r\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n\tstyleElement.parentNode.removeChild(styleElement);\r\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\tif(idx >= 0) {\r\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tinsertStyleElement(options, styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tlinkElement.rel = \"stylesheet\";\r\n\tinsertStyleElement(options, linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader/addStyles.js\n ** module id = 7\n ** module chunks = 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n **/","exports = module.exports = require(\"./../../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".venntooltip{position:absolute;text-align:center;width:128px;height:22px;background:#333;color:#ddd;border:0;border-radius:8px;opacity:0}.venn-area>.label{font-size:1em}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./static/repository/plugins/benfred/venn.css\n ** module id = 66\n ** module chunks = 20\n **/","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../../node_modules/css-loader/index.js!./venn.css\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./venn.css\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./venn.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader!./~/css-loader!./static/repository/plugins/benfred/venn.css\n ** module id = 159\n ** module chunks = 20\n **/","(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    factory((global.venn = {}),global.d3,global.d3);\n}(this, function (exports) { 'use strict';\n\n    /** finds the zeros of a function, given two starting points (which must\n     * have opposite signs */\n    function bisect(f, a, b, parameters) {\n        parameters = parameters || {};\n        var maxIterations = parameters.maxIterations || 100,\n            tolerance = parameters.tolerance || 1e-10,\n            fA = f(a),\n            fB = f(b),\n            delta = b - a;\n\n        if (fA * fB > 0) {\n            throw \"Initial bisect points must have opposite signs\";\n        }\n\n        if (fA === 0) return a;\n        if (fB === 0) return b;\n\n        for (var i = 0; i < maxIterations; ++i) {\n            delta /= 2;\n            var mid = a + delta,\n                fMid = f(mid);\n\n            if (fMid * fA >= 0) {\n                a = mid;\n            }\n\n            if ((Math.abs(delta) < tolerance) || (fMid === 0)) {\n                return mid;\n            }\n        }\n        return a + delta;\n    }\n\n    // need some basic operations on vectors, rather than adding a dependency,\n    // just define here\n    function zeros(x) { var r = new Array(x); for (var i = 0; i < x; ++i) { r[i] = 0; } return r; }\n    function zerosM(x,y) { return zeros(x).map(function() { return zeros(y); }); }\n\n    function dot(a, b) {\n        var ret = 0;\n        for (var i = 0; i < a.length; ++i) {\n            ret += a[i] * b[i];\n        }\n        return ret;\n    }\n\n    function norm2(a)  {\n        return Math.sqrt(dot(a, a));\n    }\n\n    function multiplyBy(a, c) {\n        for (var i = 0; i < a.length; ++i) {\n            a[i] *= c;\n        }\n    }\n\n    function weightedSum(ret, w1, v1, w2, v2) {\n        for (var j = 0; j < ret.length; ++j) {\n            ret[j] = w1 * v1[j] + w2 * v2[j];\n        }\n    }\n\n    /** minimizes a function using the downhill simplex method */\n    function fmin(f, x0, parameters) {\n        parameters = parameters || {};\n\n        var maxIterations = parameters.maxIterations || x0.length * 200,\n            nonZeroDelta = parameters.nonZeroDelta || 1.1,\n            zeroDelta = parameters.zeroDelta || 0.001,\n            minErrorDelta = parameters.minErrorDelta || 1e-6,\n            minTolerance = parameters.minErrorDelta || 1e-5,\n            rho = parameters.rho || 1,\n            chi = parameters.chi || 2,\n            psi = parameters.psi || -0.5,\n            sigma = parameters.sigma || 0.5,\n            callback = parameters.callback,\n            maxDiff,\n            temp;\n\n        // initialize simplex.\n        var N = x0.length,\n            simplex = new Array(N + 1);\n        simplex[0] = x0;\n        simplex[0].fx = f(x0);\n        for (var i = 0; i < N; ++i) {\n            var point = x0.slice();\n            point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n            simplex[i+1] = point;\n            simplex[i+1].fx = f(point);\n        }\n\n        var sortOrder = function(a, b) { return a.fx - b.fx; };\n\n        var centroid = x0.slice(),\n            reflected = x0.slice(),\n            contracted = x0.slice(),\n            expanded = x0.slice();\n\n        for (var iteration = 0; iteration < maxIterations; ++iteration) {\n            simplex.sort(sortOrder);\n            if (callback) {\n                callback(simplex);\n            }\n\n            maxDiff = 0;\n            for (i = 0; i < N; ++i) {\n                maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n            }\n\n            if ((Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) &&\n                (maxDiff < minTolerance)) {\n                break;\n            }\n\n            // compute the centroid of all but the worst point in the simplex\n            for (i = 0; i < N; ++i) {\n                centroid[i] = 0;\n                for (var j = 0; j < N; ++j) {\n                    centroid[i] += simplex[j][i];\n                }\n                centroid[i] /= N;\n            }\n\n            // reflect the worst point past the centroid  and compute loss at reflected\n            // point\n            var worst = simplex[N];\n            weightedSum(reflected, 1+rho, centroid, -rho, worst);\n            reflected.fx = f(reflected);\n\n            // if the reflected point is the best seen, then possibly expand\n            if (reflected.fx <= simplex[0].fx) {\n                weightedSum(expanded, 1+chi, centroid, -chi, worst);\n                expanded.fx = f(expanded);\n                if (expanded.fx < reflected.fx) {\n                    temp = simplex[N];\n                    simplex[N] = expanded;\n                    expanded = temp;\n                }  else {\n                    temp = simplex[N];\n                    simplex[N] = reflected;\n                    reflected = temp;\n                }\n            }\n\n            // if the reflected point is worse than the second worst, we need to\n            // contract\n            else if (reflected.fx >= simplex[N-1].fx) {\n                var shouldReduce = false;\n\n                if (reflected.fx > worst.fx) {\n                    // do an inside contraction\n                    weightedSum(contracted, 1+psi, centroid, -psi, worst);\n                    contracted.fx = f(contracted);\n                    if (contracted.fx < worst.fx) {\n                        temp = simplex[N];\n                        simplex[N] = contracted;\n                        contracted = temp;\n                    } else {\n                        shouldReduce = true;\n                    }\n                } else {\n                    // do an outside contraction\n                    weightedSum(contracted, 1-psi * rho, centroid, psi*rho, worst);\n                    contracted.fx = f(contracted);\n                    if (contracted.fx <= reflected.fx) {\n                        temp = simplex[N];\n                        simplex[N] = contracted;\n                        contracted = temp;\n                    } else {\n                        shouldReduce = true;\n                    }\n                }\n\n                if (shouldReduce) {\n                    // do reduction. doesn't actually happen that often\n                    for (i = 1; i < simplex.length; ++i) {\n                        weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n                        simplex[i].fx = f(simplex[i]);\n                    }\n                }\n            } else {\n                temp = simplex[N];\n                simplex[N] = reflected;\n                reflected = temp;\n            }\n\n        }\n\n        simplex.sort(sortOrder);\n        return {f : simplex[0].fx,\n                solution : simplex[0]};\n    }\n\n    function minimizeConjugateGradient(f, initial, params) {\n        // allocate all memory up front here, keep out of the loop for perfomance\n        // reasons\n        var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n            next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n            yk = initial.slice(),\n            pk, temp,\n            a = 1,\n            maxIterations;\n\n        params = params || {};\n        maxIterations = params.maxIterations || initial.length * 5;\n\n        current.fx = f(current.x, current.fxprime);\n        pk = current.fxprime.slice();\n        multiplyBy(pk, -1);\n\n        for (var i = 0; i < maxIterations; ++i) {\n            if (params.history) {\n                params.history.push({x: current.x.slice(),\n                                     fx: current.fx,\n                                     fxprime: current.fxprime.slice()});\n            }\n\n            a = wolfeLineSearch(f, pk, current, next, a);\n            if (!a) {\n                // faiiled to find point that satifies wolfe conditions.\n                // reset direction for next iteration\n                for (var j = 0; j < pk.length; ++j) {\n                    pk[j] = -1 * current.fxprime[j];\n                }\n            } else {\n                // update direction using Polak–Ribiere CG method\n                weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\n\n                var delta_k = dot(current.fxprime, current.fxprime),\n                    beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\n\n                weightedSum(pk, beta_k, pk, -1, next.fxprime);\n\n                temp = current;\n                current = next;\n                next = temp;\n            }\n\n            if (norm2(current.fxprime) <= 1e-5) {\n                break;\n            }\n        }\n\n        if (params.history) {\n            params.history.push({x: current.x.slice(),\n                                 fx: current.fx,\n                                 fxprime: current.fxprime.slice()});\n        }\n\n        return current;\n    }\n\n    var c1 = 1e-6;\n    var c2 = 0.1;\n    /// searches along line 'pk' for a point that satifies the wolfe conditions\n    /// See 'Numerical Optimization' by Nocedal and Wright p59-60\n    function wolfeLineSearch(f, pk, current, next, a) {\n        var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk),\n            phi = phi0, phi_old = phi0,\n            phiPrime = phiPrime0,\n            a0 = 0;\n\n        a = a || 1;\n\n        function zoom(a_lo, a_high, phi_lo) {\n            for (var iteration = 0; iteration < 16; ++iteration) {\n                a = (a_lo + a_high)/2;\n                weightedSum(next.x, 1.0, current.x, a, pk);\n                phi = next.fx = f(next.x, next.fxprime);\n                phiPrime = dot(next.fxprime, pk);\n\n                if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n                    (phi >= phi_lo)) {\n                    a_high = a;\n\n                } else  {\n                    if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                        return a;\n                    }\n\n                    if (phiPrime * (a_high - a_lo) >=0) {\n                        a_high = a_lo;\n                    }\n\n                    a_lo = a;\n                    phi_lo = phi;\n                }\n            }\n\n            return 0;\n        }\n\n        for (var iteration = 0; iteration < 10; ++iteration) {\n            weightedSum(next.x, 1.0, current.x, a, pk);\n            phi = next.fx = f(next.x, next.fxprime);\n            phiPrime = dot(next.fxprime, pk);\n            if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n                (iteration && (phi >= phi_old))) {\n                return zoom(a0, a, phi_old);\n            }\n\n            if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                return a;\n            }\n\n            if (phiPrime >= 0 ) {\n                return zoom(a, a0, phi);\n            }\n\n            phi_old = phi;\n            a0 = a;\n            a *= 2;\n        }\n\n        return 0;\n    }\n\n    var SMALL = 1e-10;\n\n    /** Returns the intersection area of a bunch of circles (where each circle\n     is an object having an x,y and radius property) */\n    function intersectionArea(circles, stats) {\n        // get all the intersection points of the circles\n        var intersectionPoints = getIntersectionPoints(circles);\n\n        // filter out points that aren't included in all the circles\n        var innerPoints = intersectionPoints.filter(function (p) {\n            return containedInCircles(p, circles);\n        });\n\n        var arcArea = 0, polygonArea = 0, arcs = [], i;\n\n        // if we have intersection points that are within all the circles,\n        // then figure out the area contained by them\n        if (innerPoints.length > 1) {\n            // sort the points by angle from the center of the polygon, which lets\n            // us just iterate over points to get the edges\n            var center = getCenter(innerPoints);\n            for (i = 0; i < innerPoints.length; ++i ) {\n                var p = innerPoints[i];\n                p.angle = Math.atan2(p.x - center.x, p.y - center.y);\n            }\n            innerPoints.sort(function(a,b) { return b.angle - a.angle;});\n\n            // iterate over all points, get arc between the points\n            // and update the areas\n            var p2 = innerPoints[innerPoints.length - 1];\n            for (i = 0; i < innerPoints.length; ++i) {\n                var p1 = innerPoints[i];\n\n                // polygon area updates easily ...\n                polygonArea += (p2.x + p1.x) * (p1.y - p2.y);\n\n                // updating the arc area is a little more involved\n                var midPoint = {x : (p1.x + p2.x) / 2,\n                                y : (p1.y + p2.y) / 2},\n                    arc = null;\n\n                for (var j = 0; j < p1.parentIndex.length; ++j) {\n                    if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {\n                        // figure out the angle halfway between the two points\n                        // on the current circle\n                        var circle = circles[p1.parentIndex[j]],\n                            a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),\n                            a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);\n\n                        var angleDiff = (a2 - a1);\n                        if (angleDiff < 0) {\n                            angleDiff += 2*Math.PI;\n                        }\n\n                        // and use that angle to figure out the width of the\n                        // arc\n                        var a = a2 - angleDiff/2,\n                            width = distance(midPoint, {\n                                x : circle.x + circle.radius * Math.sin(a),\n                                y : circle.y + circle.radius * Math.cos(a)\n                            });\n\n                        // pick the circle whose arc has the smallest width\n                        if ((arc === null) || (arc.width > width)) {\n                            arc = { circle : circle,\n                                    width : width,\n                                    p1 : p1,\n                                    p2 : p2};\n                        }\n                    }\n                }\n\n                if (arc !== null) {\n                    arcs.push(arc);\n                    arcArea += circleArea(arc.circle.radius, arc.width);\n                    p2 = p1;\n                }\n            }\n        } else {\n            // no intersection points, is either disjoint - or is completely\n            // overlapped. figure out which by examining the smallest circle\n            var smallest = circles[0];\n            for (i = 1; i < circles.length; ++i) {\n                if (circles[i].radius < smallest.radius) {\n                    smallest = circles[i];\n                }\n            }\n\n            // make sure the smallest circle is completely contained in all\n            // the other circles\n            var disjoint = false;\n            for (i = 0; i < circles.length; ++i) {\n                if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {\n                    disjoint = true;\n                    break;\n                }\n            }\n\n            if (disjoint) {\n                arcArea = polygonArea = 0;\n\n            } else {\n                arcArea = smallest.radius * smallest.radius * Math.PI;\n                arcs.push({circle : smallest,\n                           p1: { x: smallest.x,        y : smallest.y + smallest.radius},\n                           p2: { x: smallest.x - SMALL, y : smallest.y + smallest.radius},\n                           width : smallest.radius * 2 });\n            }\n        }\n\n        polygonArea /= 2;\n        if (stats) {\n            stats.area = arcArea + polygonArea;\n            stats.arcArea = arcArea;\n            stats.polygonArea = polygonArea;\n            stats.arcs = arcs;\n            stats.innerPoints = innerPoints;\n            stats.intersectionPoints = intersectionPoints;\n        }\n\n        return arcArea + polygonArea;\n    }\n\n    /** returns whether a point is contained by all of a list of circles */\n    function containedInCircles(point, circles) {\n        for (var i = 0; i < circles.length; ++i) {\n            if (distance(point, circles[i]) > circles[i].radius + SMALL) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /** Gets all intersection points between a bunch of circles */\n    function getIntersectionPoints(circles) {\n        var ret = [];\n        for (var i = 0; i < circles.length; ++i) {\n            for (var j = i + 1; j < circles.length; ++j) {\n                var intersect = circleCircleIntersection(circles[i],\n                                                              circles[j]);\n                for (var k = 0; k < intersect.length; ++k) {\n                    var p = intersect[k];\n                    p.parentIndex = [i,j];\n                    ret.push(p);\n                }\n            }\n        }\n        return ret;\n    }\n\n    function circleIntegral(r, x) {\n        var y = Math.sqrt(r * r - x * x);\n        return x * y + r * r * Math.atan2(x, y);\n    }\n\n    /** Returns the area of a circle of radius r - up to width */\n    function circleArea(r, width) {\n        return circleIntegral(r, width - r) - circleIntegral(r, -r);\n    }\n\n    /** euclidean distance between two points */\n    function distance(p1, p2) {\n        return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) +\n                         (p1.y - p2.y) * (p1.y - p2.y));\n    }\n\n\n    /** Returns the overlap area of two circles of radius r1 and r2 - that\n    have their centers separated by distance d. Simpler faster\n    circle intersection for only two circles */\n    function circleOverlap(r1, r2, d) {\n        // no overlap\n        if (d >= r1 + r2) {\n            return 0;\n        }\n\n        // completely overlapped\n        if (d <= Math.abs(r1 - r2)) {\n            return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);\n        }\n\n        var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),\n            w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);\n        return circleArea(r1, w1) + circleArea(r2, w2);\n    }\n\n    /** Given two circles (containing a x/y/radius attributes),\n    returns the intersecting points if possible.\n    note: doesn't handle cases where there are infinitely many\n    intersection points (circles are equivalent):, or only one intersection point*/\n    function circleCircleIntersection(p1, p2) {\n        var d = distance(p1, p2),\n            r1 = p1.radius,\n            r2 = p2.radius;\n\n        // if to far away, or self contained - can't be done\n        if ((d >= (r1 + r2)) || (d <= Math.abs(r1 - r2))) {\n            return [];\n        }\n\n        var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),\n            h = Math.sqrt(r1 * r1 - a * a),\n            x0 = p1.x + a * (p2.x - p1.x) / d,\n            y0 = p1.y + a * (p2.y - p1.y) / d,\n            rx = -(p2.y - p1.y) * (h / d),\n            ry = -(p2.x - p1.x) * (h / d);\n\n        return [{x: x0 + rx, y : y0 - ry },\n                {x: x0 - rx, y : y0 + ry }];\n    }\n\n    /** Returns the center of a bunch of points */\n    function getCenter(points) {\n        var center = {x: 0, y: 0};\n        for (var i =0; i < points.length; ++i ) {\n            center.x += points[i].x;\n            center.y += points[i].y;\n        }\n        center.x /= points.length;\n        center.y /= points.length;\n        return center;\n    }\n\n    /** given a list of set objects, and their corresponding overlaps.\n    updates the (x, y, radius) attribute on each set such that their positions\n    roughly correspond to the desired overlaps */\n    function venn(areas, parameters) {\n        parameters = parameters || {};\n        parameters.maxIterations = parameters.maxIterations || 500;\n        var initialLayout = parameters.initialLayout || bestInitialLayout;\n\n        // add in missing pairwise areas as having 0 size\n        areas = addMissingAreas(areas);\n\n        // initial layout is done greedily\n        var circles = initialLayout(areas);\n\n        // transform x/y coordinates to a vector to optimize\n        var initial = [], setids = [], setid;\n        for (setid in circles) {\n            if (circles.hasOwnProperty(setid)) {\n                initial.push(circles[setid].x);\n                initial.push(circles[setid].y);\n                setids.push(setid);\n            }\n        }\n\n        // optimize initial layout from our loss function\n        var totalFunctionCalls = 0;\n        var solution = fmin(\n            function(values) {\n                totalFunctionCalls += 1;\n                var current = {};\n                for (var i = 0; i < setids.length; ++i) {\n                    var setid = setids[i];\n                    current[setid] = {x: values[2 * i],\n                                      y: values[2 * i + 1],\n                                      radius : circles[setid].radius,\n                                     // size : circles[setid].size\n                                     };\n                }\n                return lossFunction(current, areas);\n            },\n            initial,\n            parameters);\n\n        // transform solution vector back to x/y points\n        var positions = solution.solution;\n        for (var i = 0; i < setids.length; ++i) {\n            setid = setids[i];\n            circles[setid].x = positions[2 * i];\n            circles[setid].y = positions[2 * i + 1];\n        }\n\n        return circles;\n    }\n\n    var SMALL$1 = 1e-10;\n\n    /** Returns the distance necessary for two circles of radius r1 + r2 to\n    have the overlap area 'overlap' */\n    function distanceFromIntersectArea(r1, r2, overlap) {\n        // handle complete overlapped circles\n        if (Math.min(r1, r2) * Math.min(r1,r2) * Math.PI <= overlap + SMALL$1) {\n            return Math.abs(r1 - r2);\n        }\n\n        return bisect(function(distance) {\n            return circleOverlap(r1, r2, distance) - overlap;\n        }, 0, r1 + r2);\n    }\n\n    /** Missing pair-wise intersection area data can cause problems:\n     treating as an unknown means that sets will be laid out overlapping,\n     which isn't what people expect. To reflect that we want disjoint sets\n     here, set the overlap to 0 for all missing pairwise set intersections */\n    function addMissingAreas(areas) {\n        areas = areas.slice();\n\n        // two circle intersections that aren't defined\n        var ids = [], pairs = {}, i, j, a, b;\n        for (i = 0; i < areas.length; ++i) {\n            var area = areas[i];\n            if (area.sets.length == 1) {\n                ids.push(area.sets[0]);\n            } else if (area.sets.length == 2) {\n                a = area.sets[0];\n                b = area.sets[1];\n                pairs[[a, b]] = true;\n                pairs[[b, a]] = true;\n            }\n        }\n        ids.sort(function(a, b) { return a > b; });\n\n        for (i = 0; i < ids.length; ++i) {\n            a = ids[i];\n            for (j = i + 1; j < ids.length; ++j) {\n                b = ids[j];\n                if (!([a, b] in pairs)) {\n                    areas.push({'sets': [a, b],\n                                'size': 0});\n                }\n            }\n        }\n        return areas;\n    }\n\n    /// Returns two matrices, one of the euclidean distances between the sets\n    /// and the other indicating if there are subset or disjoint set relationships\n    function getDistanceMatrices(areas, sets, setids) {\n        // initialize an empty distance matrix between all the points\n        var distances = zerosM(sets.length, sets.length),\n            constraints = zerosM(sets.length, sets.length);\n\n        // compute required distances between all the sets such that\n        // the areas match\n        areas.filter(function(x) { return x.sets.length == 2; })\n            .map(function(current) {\n            var left = setids[current.sets[0]],\n                right = setids[current.sets[1]],\n                r1 = Math.sqrt(sets[left].size / Math.PI),\n                r2 = Math.sqrt(sets[right].size / Math.PI),\n                distance = distanceFromIntersectArea(r1, r2, current.size);\n\n            distances[left][right] = distances[right][left] = distance;\n\n            // also update constraints to indicate if its a subset or disjoint\n            // relationship\n            var c = 0;\n            if (current.size + 1e-10 >= Math.min(sets[left].size,\n                                                 sets[right].size)) {\n                c = 1;\n            } else if (current.size <= 1e-10) {\n                c = -1;\n            }\n            constraints[left][right] = constraints[right][left] = c;\n        });\n\n        return {distances: distances, constraints: constraints};\n    }\n\n    /// computes the gradient and loss simulatenously for our constrained MDS optimizer\n    function constrainedMDSGradient(x, fxprime, distances, constraints) {\n        var loss = 0, i;\n        for (i = 0; i < fxprime.length; ++i) {\n            fxprime[i] = 0;\n        }\n\n        for (i = 0; i < distances.length; ++i) {\n            var xi = x[2 * i], yi = x[2 * i + 1];\n            for (var j = i + 1; j < distances.length; ++j) {\n                var xj = x[2 * j], yj = x[2 * j + 1],\n                    dij = distances[i][j],\n                    constraint = constraints[i][j];\n\n                var squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi),\n                    distance = Math.sqrt(squaredDistance),\n                    delta = squaredDistance - dij * dij;\n\n                if (((constraint > 0) && (distance <= dij)) ||\n                    ((constraint < 0) && (distance >= dij))) {\n                    continue;\n                }\n\n                loss += 2 * delta * delta;\n\n                fxprime[2*i]     += 4 * delta * (xi - xj);\n                fxprime[2*i + 1] += 4 * delta * (yi - yj);\n\n                fxprime[2*j]     += 4 * delta * (xj - xi);\n                fxprime[2*j + 1] += 4 * delta * (yj - yi);\n            }\n        }\n        return loss;\n    }\n\n    /// takes the best working variant of either constrained MDS or greedy\n    function bestInitialLayout(areas, params) {\n        var initial = greedyLayout(areas, params);\n\n        // greedylayout is sufficient for all 2/3 circle cases. try out\n        // constrained MDS for higher order problems, take its output\n        // if it outperforms. (greedy is aesthetically better on 2/3 circles\n        // since it axis aligns)\n        if (areas.length >= 8) {\n            var constrained  = constrainedMDSLayout(areas, params),\n                constrainedLoss = lossFunction(constrained, areas),\n                greedyLoss = lossFunction(initial, areas);\n\n            if (constrainedLoss + 1e-8 < greedyLoss) {\n                initial = constrained;\n            }\n        }\n        return initial;\n    }\n\n    /// use the constrained MDS variant to generate an initial layout\n    function constrainedMDSLayout(areas, params) {\n        params = params || {};\n        var restarts = params.restarts || 10;\n\n        // bidirectionally map sets to a rowid  (so we can create a matrix)\n        var sets = [], setids = {}, i;\n        for (i = 0; i < areas.length; ++i ) {\n            var area = areas[i];\n            if (area.sets.length == 1) {\n                setids[area.sets[0]] = sets.length;\n                sets.push(area);\n            }\n        }\n\n        var matrices = getDistanceMatrices(areas, sets, setids),\n            distances = matrices.distances,\n            constraints = matrices.constraints;\n\n        // keep distances bounded, things get messed up otherwise.\n        // TODO: proper preconditioner?\n        var norm = norm2(distances.map(norm2))/(distances.length);\n        distances = distances.map(function (row) {\n            return row.map(function (value) { return value / norm; });});\n\n        var obj = function(x, fxprime) {\n            return constrainedMDSGradient(x, fxprime, distances, constraints);\n        };\n\n        var best, current;\n        for (i = 0; i < restarts; ++i) {\n            var initial = zeros(distances.length*2).map(Math.random);\n\n            current = minimizeConjugateGradient(obj, initial, params);\n            if (!best || (current.fx < best.fx)) {\n                best = current;\n            }\n        }\n        var positions = best.x;\n\n        // translate rows back to (x,y,radius) coordinates\n        var circles = {};\n        for (i = 0; i < sets.length; ++i) {\n            var set = sets[i];\n            circles[set.sets[0]] = {\n                x: positions[2*i] * norm,\n                y: positions[2*i + 1] * norm,\n                radius:  Math.sqrt(set.size / Math.PI)\n            };\n        }\n\n        if (params.history) {\n            for (i = 0; i < params.history.length; ++i) {\n                multiplyBy(params.history[i].x, norm);\n            }\n        }\n        return circles;\n    }\n\n    /** Lays out a Venn diagram greedily, going from most overlapped sets to\n    least overlapped, attempting to position each new set such that the\n    overlapping areas to already positioned sets are basically right */\n    function greedyLayout(areas) {\n        // define a circle for each set\n        var circles = {}, setOverlaps = {}, set;\n        for (var i = 0; i < areas.length; ++i) {\n            var area = areas[i];\n            if (area.sets.length == 1) {\n                set = area.sets[0];\n                circles[set] = {x: 1e10, y: 1e10,\n                                rowid: circles.length,\n                                size: area.size,\n                                radius: Math.sqrt(area.size / Math.PI)};\n                setOverlaps[set] = [];\n            }\n        }\n        areas = areas.filter(function(a) { return a.sets.length == 2; });\n\n        // map each set to a list of all the other sets that overlap it\n        for (i = 0; i < areas.length; ++i) {\n            var current = areas[i];\n            var weight = current.hasOwnProperty('weight') ? current.weight : 1.0;\n            var left = current.sets[0], right = current.sets[1];\n\n            // completely overlapped circles shouldn't be positioned early here\n            if (current.size + SMALL$1 >= Math.min(circles[left].size,\n                                                 circles[right].size)) {\n                weight = 0;\n            }\n\n            setOverlaps[left].push ({set:right, size:current.size, weight:weight});\n            setOverlaps[right].push({set:left,  size:current.size, weight:weight});\n        }\n\n        // get list of most overlapped sets\n        var mostOverlapped = [];\n        for (set in setOverlaps) {\n            if (setOverlaps.hasOwnProperty(set)) {\n                var size = 0;\n                for (i = 0; i < setOverlaps[set].length; ++i) {\n                    size += setOverlaps[set][i].size * setOverlaps[set][i].weight;\n                }\n\n                mostOverlapped.push({set: set, size:size});\n            }\n        }\n\n        // sort by size desc\n        function sortOrder(a,b) {\n            return b.size - a.size;\n        }\n        mostOverlapped.sort(sortOrder);\n\n        // keep track of what sets have been laid out\n        var positioned = {};\n        function isPositioned(element) {\n            return element.set in positioned;\n        }\n\n        // adds a point to the output\n        function positionSet(point, index) {\n            circles[index].x = point.x;\n            circles[index].y = point.y;\n            positioned[index] = true;\n        }\n\n        // add most overlapped set at (0,0)\n        positionSet({x: 0, y: 0}, mostOverlapped[0].set);\n\n        // get distances between all points. TODO, necessary?\n        // answer: probably not\n        // var distances = venn.getDistanceMatrices(circles, areas).distances;\n        for (i = 1; i < mostOverlapped.length; ++i) {\n            var setIndex = mostOverlapped[i].set,\n                overlap = setOverlaps[setIndex].filter(isPositioned);\n            set = circles[setIndex];\n            overlap.sort(sortOrder);\n\n            if (overlap.length === 0) {\n                // this shouldn't happen anymore with addMissingAreas\n                throw \"ERROR: missing pairwise overlap information\";\n            }\n\n            var points = [];\n            for (var j = 0; j < overlap.length; ++j) {\n                // get appropriate distance from most overlapped already added set\n                var p1 = circles[overlap[j].set],\n                    d1 = distanceFromIntersectArea(set.radius, p1.radius,\n                                                   overlap[j].size);\n\n                // sample positions at 90 degrees for maximum aesthetics\n                points.push({x : p1.x + d1, y : p1.y});\n                points.push({x : p1.x - d1, y : p1.y});\n                points.push({y : p1.y + d1, x : p1.x});\n                points.push({y : p1.y - d1, x : p1.x});\n\n                // if we have at least 2 overlaps, then figure out where the\n                // set should be positioned analytically and try those too\n                for (var k = j + 1; k < overlap.length; ++k) {\n                    var p2 = circles[overlap[k].set],\n                        d2 = distanceFromIntersectArea(set.radius, p2.radius,\n                                                       overlap[k].size);\n\n                    var extraPoints = circleCircleIntersection(\n                        { x: p1.x, y: p1.y, radius: d1},\n                        { x: p2.x, y: p2.y, radius: d2});\n\n                    for (var l = 0; l < extraPoints.length; ++l) {\n                        points.push(extraPoints[l]);\n                    }\n                }\n            }\n\n            // we have some candidate positions for the set, examine loss\n            // at each position to figure out where to put it at\n            var bestLoss = 1e50, bestPoint = points[0];\n            for (j = 0; j < points.length; ++j) {\n                circles[setIndex].x = points[j].x;\n                circles[setIndex].y = points[j].y;\n                var loss = lossFunction(circles, areas);\n                if (loss < bestLoss) {\n                    bestLoss = loss;\n                    bestPoint = points[j];\n                }\n            }\n\n            positionSet(bestPoint, setIndex);\n        }\n\n        return circles;\n    }\n\n    /** Given a bunch of sets, and the desired overlaps between these sets - computes\n    the distance from the actual overlaps to the desired overlaps. Note that\n    this method ignores overlaps of more than 2 circles */\n    function lossFunction(sets, overlaps) {\n        var output = 0;\n\n        function getCircles(indices) {\n            return indices.map(function(i) { return sets[i]; });\n        }\n\n        for (var i = 0; i < overlaps.length; ++i) {\n            var area = overlaps[i], overlap;\n            if (area.sets.length == 1) {\n                continue;\n            } else if (area.sets.length == 2) {\n                var left = sets[area.sets[0]],\n                    right = sets[area.sets[1]];\n                overlap = circleOverlap(left.radius, right.radius,\n                                        distance(left, right));\n            } else {\n                overlap = intersectionArea(getCircles(area.sets));\n            }\n\n            var weight = area.hasOwnProperty('weight') ? area.weight : 1.0;\n            output += weight * (overlap - area.size) * (overlap - area.size);\n        }\n\n        return output;\n    }\n\n    // orientates a bunch of circles to point in orientation\n    function orientateCircles(circles, orientation, orientationOrder) {\n        if (orientationOrder === null) {\n            circles.sort(function (a, b) { return b.radius - a.radius; });\n        } else {\n            circles.sort(orientationOrder);\n        }\n\n        var i;\n        // shift circles so largest circle is at (0, 0)\n        if (circles.length > 0) {\n            var largestX = circles[0].x,\n                largestY = circles[0].y;\n\n            for (i = 0; i < circles.length; ++i) {\n                circles[i].x -= largestX;\n                circles[i].y -= largestY;\n            }\n        }\n\n        // rotate circles so that second largest is at an angle of 'orientation'\n        // from largest\n        if (circles.length > 1) {\n            var rotation = Math.atan2(circles[1].x, circles[1].y) - orientation,\n                c = Math.cos(rotation),\n                s = Math.sin(rotation), x, y;\n\n            for (i = 0; i < circles.length; ++i) {\n                x = circles[i].x;\n                y = circles[i].y;\n                circles[i].x = c * x - s * y;\n                circles[i].y = s * x + c * y;\n            }\n        }\n\n        // mirror solution if third solution is above plane specified by\n        // first two circles\n        if (circles.length > 2) {\n            var angle = Math.atan2(circles[2].x, circles[2].y) - orientation;\n            while (angle < 0) { angle += 2* Math.PI; }\n            while (angle > 2*Math.PI) { angle -= 2* Math.PI; }\n            if (angle > Math.PI) {\n                var slope = circles[1].y / (1e-10 + circles[1].x);\n                for (i = 0; i < circles.length; ++i) {\n                    var d = (circles[i].x + slope * circles[i].y) / (1 + slope*slope);\n                    circles[i].x = 2 * d - circles[i].x;\n                    circles[i].y = 2 * d * slope - circles[i].y;\n                }\n            }\n        }\n    }\n\n    function disjointCluster(circles) {\n        // union-find clustering to get disjoint sets\n        circles.map(function(circle) { circle.parent = circle; });\n\n        // path compression step in union find\n        function find(circle) {\n            if (circle.parent !== circle) {\n                circle.parent = find(circle.parent);\n            }\n            return circle.parent;\n        }\n\n        function union(x, y) {\n            var xRoot = find(x), yRoot = find(y);\n            xRoot.parent = yRoot;\n        }\n\n        // get the union of all overlapping sets\n        for (var i = 0; i < circles.length; ++i) {\n            for (var j = i + 1; j < circles.length; ++j) {\n                var maxDistance = circles[i].radius + circles[j].radius;\n                if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {\n                    union(circles[j], circles[i]);\n                }\n            }\n        }\n\n        // find all the disjoint clusters and group them together\n        var disjointClusters = {}, setid;\n        for (i = 0; i < circles.length; ++i) {\n            setid = find(circles[i]).parent.setid;\n            if (!(setid in disjointClusters)) {\n                disjointClusters[setid] = [];\n            }\n            disjointClusters[setid].push(circles[i]);\n        }\n\n        // cleanup bookkeeping\n        circles.map(function(circle) { delete circle.parent; });\n\n        // return in more usable form\n        var ret = [];\n        for (setid in disjointClusters) {\n            if (disjointClusters.hasOwnProperty(setid)) {\n                ret.push(disjointClusters[setid]);\n            }\n        }\n        return ret;\n    }\n\n    function getBoundingBox(circles) {\n        var minMax = function(d) {\n            var hi = Math.max.apply(null, circles.map(\n                                    function(c) { return c[d] + c.radius; } )),\n                lo = Math.min.apply(null, circles.map(\n                                    function(c) { return c[d] - c.radius;} ));\n            return {max:hi, min:lo};\n        };\n\n        return {xRange: minMax('x'), yRange: minMax('y')};\n    }\n\n    function normalizeSolution(solution, orientation, orientationOrder) {\n        if (orientation === null){\n            orientation = Math.PI/2;\n        }\n\n        // work with a list instead of a dictionary, and take a copy so we\n        // don't mutate input\n        var circles = [], i, setid;\n        for (setid in solution) {\n            if (solution.hasOwnProperty(setid)) {\n                var previous = solution[setid];\n                circles.push({x: previous.x,\n                              y: previous.y,\n                              radius: previous.radius,\n                              setid: setid});\n            }\n        }\n\n        // get all the disjoint clusters\n        var clusters = disjointCluster(circles);\n\n        // orientate all disjoint sets, get sizes\n        for (i = 0; i < clusters.length; ++i) {\n            orientateCircles(clusters[i], orientation, orientationOrder);\n            var bounds = getBoundingBox(clusters[i]);\n            clusters[i].size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);\n            clusters[i].bounds = bounds;\n        }\n        clusters.sort(function(a, b) { return b.size - a.size; });\n\n        // orientate the largest at 0,0, and get the bounds\n        circles = clusters[0];\n        var returnBounds = circles.bounds;\n\n        var spacing = (returnBounds.xRange.max - returnBounds.xRange.min)/50;\n\n        function addCluster(cluster, right, bottom) {\n            if (!cluster) return;\n\n            var bounds = cluster.bounds, xOffset, yOffset, centreing;\n\n            if (right) {\n                xOffset = returnBounds.xRange.max  - bounds.xRange.min + spacing;\n            } else {\n                xOffset = returnBounds.xRange.max  - bounds.xRange.max;\n                centreing = (bounds.xRange.max - bounds.xRange.min) / 2 -\n                            (returnBounds.xRange.max - returnBounds.xRange.min) / 2;\n                if (centreing < 0) xOffset += centreing;\n            }\n\n            if (bottom) {\n                yOffset = returnBounds.yRange.max  - bounds.yRange.min + spacing;\n            } else {\n                yOffset = returnBounds.yRange.max  - bounds.yRange.max;\n                centreing = (bounds.yRange.max - bounds.yRange.min) / 2 -\n                            (returnBounds.yRange.max - returnBounds.yRange.min) / 2;\n                if (centreing < 0) yOffset += centreing;\n            }\n\n            for (var j = 0; j < cluster.length; ++j) {\n                cluster[j].x += xOffset;\n                cluster[j].y += yOffset;\n                circles.push(cluster[j]);\n            }\n        }\n\n        var index = 1;\n        while (index < clusters.length) {\n            addCluster(clusters[index], true, false);\n            addCluster(clusters[index+1], false, true);\n            addCluster(clusters[index+2], true, true);\n            index += 3;\n\n            // have one cluster (in top left). lay out next three relative\n            // to it in a grid\n            returnBounds = getBoundingBox(circles);\n        }\n\n        // convert back to solution form\n        var ret = {};\n        for (i = 0; i < circles.length; ++i) {\n            ret[circles[i].setid] = circles[i];\n        }\n        return ret;\n    }\n\n    /** Scales a solution from venn.venn or venn.greedyLayout such that it fits in\n    a rectangle of width/height - with padding around the borders. also\n    centers the diagram in the available space at the same time */\n    function scaleSolution(solution, width, height, padding) {\n        var circles = [], setids = [];\n        for (var setid in solution) {\n            if (solution.hasOwnProperty(setid)) {\n                setids.push(setid);\n                circles.push(solution[setid]);\n            }\n        }\n\n        width -= 2*padding;\n        height -= 2*padding;\n\n        var bounds = getBoundingBox(circles),\n            xRange = bounds.xRange,\n            yRange = bounds.yRange,\n            xScaling = width  / (xRange.max - xRange.min),\n            yScaling = height / (yRange.max - yRange.min),\n            scaling = Math.min(yScaling, xScaling),\n\n            // while we're at it, center the diagram too\n            xOffset = (width -  (xRange.max - xRange.min) * scaling) / 2,\n            yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;\n\n        var scaled = {};\n        for (var i = 0; i < circles.length; ++i) {\n            var circle = circles[i];\n            scaled[setids[i]] = {\n                radius: scaling * circle.radius,\n                x: padding + xOffset + (circle.x - xRange.min) * scaling,\n                y: padding + yOffset + (circle.y - yRange.min) * scaling,\n            };\n        }\n\n        return scaled;\n    }\n\n    /*global console:true*/\n\n    function VennDiagram() {\n        var width = 600,\n            height = 350,\n            padding = 15,\n            duration = 1000,\n            orientation = Math.PI / 2,\n            normalize = true,\n            wrap = true,\n            styled = true,\n            fontSize = null,\n            orientationOrder = null,\n\n            // mimic the behaviour of d3.scale.category10 from the previous\n            // version of d3\n            colourMap = {},\n\n            // so this is the same as d3.schemeCategory10, which is only defined in d3 4.0\n            // since we can support older versions of d3 as long as we don't force this,\n            // I'm hackily redefining below. TODO: remove this and change to d3.schemeCategory10\n            colourScheme = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\", \"#e377c2\", \"#7f7f7f\", \"#bcbd22\", \"#17becf\"],\n            colourIndex = 0,\n            colours = function(key) {\n                if (key in colourMap) {\n                    return colourMap[key];\n                }\n                var ret = colourMap[key] = colourScheme[colourIndex];\n                colourIndex += 1;\n                if (colourIndex >= colourScheme.length) {\n                    colourIndex = 0;\n                }\n                return ret;\n            },\n            layoutFunction = venn;\n\n        function chart(selection) {\n            var data = selection.datum();\n            var solution = layoutFunction(data);\n            if (normalize) {\n                solution = normalizeSolution(solution,\n                                             orientation,\n                                             orientationOrder);\n            }\n            var circles = scaleSolution(solution, width, height, padding);\n            var textCentres = computeTextCentres(circles, data);\n\n            // create svg if not already existing\n            selection.selectAll(\"svg\").data([circles]).enter().append(\"svg\");\n\n            var svg = selection.select(\"svg\")\n                .attr(\"width\", width)\n                .attr(\"height\", height);\n\n            // to properly transition intersection areas, we need the\n            // previous circles locations. load from elements\n            var previous = {}, hasPrevious = false;\n            svg.selectAll(\"g path\").each(function (d) {\n                var path = d3.select(this).attr(\"d\");\n                if ((d.sets.length == 1) && path) {\n                    hasPrevious = true;\n                    previous[d.sets[0]] = circleFromPath(path);\n                }\n            });\n\n            // interpolate intersection area paths between previous and\n            // current paths\n            var pathTween = function(d) {\n                return function(t) {\n                    var c = d.sets.map(function(set) {\n                        var start = previous[set], end = circles[set];\n                        if (!start) {\n                            start = {x : width/2, y : height/2, radius : 1};\n                        }\n                        if (!end) {\n                            end = {x : width/2, y : height/2, radius : 1};\n                        }\n                        return {'x' : start.x * (1 - t) + end.x * t,\n                                'y' : start.y * (1 - t) + end.y * t,\n                                'radius' : start.radius * (1 - t) + end.radius * t};\n                    });\n                    return intersectionAreaPath(c);\n                };\n            };\n\n            // update data, joining on the set ids\n            var nodes = svg.selectAll(\"g\")\n                .data(data, function(d) { return d.sets; });\n\n            // create new nodes\n            var enter = nodes.enter()\n                .append('g')\n                .attr(\"class\", function(d) {\n                    return \"venn-area venn-\" +\n                        (d.sets.length == 1 ? \"circle\" : \"intersection\");\n                })\n                .attr(\"data-venn-sets\", function(d) {\n                    return d.sets.join(\"_\");\n                });\n\n            var enterPath = enter.append(\"path\"),\n                enterText = enter.append(\"text\")\n                .attr(\"class\", \"label\")\n                .text(function (d) { return label(d); } )\n                .attr(\"text-anchor\", \"middle\")\n                .attr(\"dy\", \".35em\")\n                .attr(\"x\", width/2)\n                .attr(\"y\", height/2);\n\n\n            // apply minimal style if wanted\n            if (styled) {\n                enterPath.style(\"fill-opacity\", \"0\")\n                    .filter(function (d) { return d.sets.length == 1; } )\n                    .style(\"fill\", function(d) { return colours(label(d)); })\n                    .style(\"fill-opacity\", \".25\");\n\n                enterText\n                    .style(\"fill\", function(d) { return d.sets.length == 1 ? colours(label(d)) : \"#444\"; });\n            }\n\n            // update existing, using pathTween if necessary\n            var update = selection;\n            if (hasPrevious) {\n                update = selection.transition(\"venn\").duration(duration);\n                update.selectAll(\"path\")\n                    .attrTween(\"d\", pathTween);\n            } else {\n                update.selectAll(\"path\")\n                    .attr(\"d\", function(d) {\n                        return intersectionAreaPath(d.sets.map(function (set) { return circles[set]; }));\n                    });\n            }\n\n            var updateText = update.selectAll(\"text\")\n                .filter(function (d) { return d.sets in textCentres; })\n                .text(function (d) { return label(d); } )\n                .attr(\"x\", function(d) { return Math.floor(textCentres[d.sets].x);})\n                .attr(\"y\", function(d) { return Math.floor(textCentres[d.sets].y);});\n\n            if (wrap) {\n                if (hasPrevious) {\n                    // d3 4.0 uses 'on' for events on transitions,\n                    // but d3 3.0 used 'each' instead. switch appropiately\n                    if ('on' in updateText) {\n                        updateText.on(\"end\", wrapText(circles, label));\n                    } else {\n                        updateText.each(\"end\", wrapText(circles, label));\n                    }\n                } else {\n                    updateText.each(wrapText(circles, label));\n                }\n            }\n\n            // remove old\n            var exit = nodes.exit().transition('venn').duration(duration).remove();\n            exit.selectAll(\"path\")\n                .attrTween(\"d\", pathTween);\n\n            var exitText = exit.selectAll(\"text\")\n                .attr(\"x\", width/2)\n                .attr(\"y\", height/2);\n\n            // if we've been passed a fontSize explicitly, use it to\n            // transition\n            if (fontSize !== null) {\n                enterText.style(\"font-size\", \"0px\");\n                updateText.style(\"font-size\", fontSize);\n                exitText.style(\"font-size\", \"0px\");\n            }\n\n\n            return {'circles': circles,\n                    'textCentres': textCentres,\n                    'nodes': nodes,\n                    'enter': enter,\n                    'update': update,\n                    'exit': exit};\n        }\n\n        function label(d) {\n            if (d.label) {\n                return d.label;\n            }\n            if (d.sets.length == 1) {\n                return '' + d.sets[0];\n            }\n        }\n\n        chart.wrap = function(_) {\n            if (!arguments.length) return wrap;\n            wrap = _;\n            return chart;\n        };\n\n        chart.width = function(_) {\n            if (!arguments.length) return width;\n            width = _;\n            return chart;\n        };\n\n        chart.height = function(_) {\n            if (!arguments.length) return height;\n            height = _;\n            return chart;\n        };\n\n        chart.padding = function(_) {\n            if (!arguments.length) return padding;\n            padding = _;\n            return chart;\n        };\n\n        chart.colours = function(_) {\n            if (!arguments.length) return colours;\n            colours = _;\n            return chart;\n        };\n\n        chart.fontSize = function(_) {\n            if (!arguments.length) return fontSize;\n            fontSize = _;\n            return chart;\n        };\n\n        chart.duration = function(_) {\n            if (!arguments.length) return duration;\n            duration = _;\n            return chart;\n        };\n\n        chart.layoutFunction = function(_) {\n            if (!arguments.length) return layoutFunction;\n            layoutFunction = _;\n            return chart;\n        };\n\n        chart.normalize = function(_) {\n            if (!arguments.length) return normalize;\n            normalize = _;\n            return chart;\n        };\n\n        chart.styled = function(_) {\n            if (!arguments.length) return styled;\n            styled = _;\n            return chart;\n        };\n\n        chart.orientation = function(_) {\n            if (!arguments.length) return orientation;\n            orientation = _;\n            return chart;\n        };\n\n        chart.orientationOrder = function(_) {\n            if (!arguments.length) return orientationOrder;\n            orientationOrder = _;\n            return chart;\n        };\n\n        return chart;\n    }\n    // sometimes text doesn't fit inside the circle, if thats the case lets wrap\n    // the text here such that it fits\n    // todo: looks like this might be merged into d3 (\n    // https://github.com/mbostock/d3/issues/1642),\n    // also worth checking out is\n    // http://engineering.findthebest.com/wrapping-axis-labels-in-d3-js/\n    // this seems to be one of those things that should be easy but isn't\n    function wrapText(circles, labeller) {\n        return function() {\n            var text = d3.select(this),\n                data = text.datum(),\n                width = circles[data.sets[0]].radius || 50,\n                label = labeller(data) || '';\n\n                var words = label.split(/\\s+/).reverse(),\n                maxLines = 3,\n                minChars = (label.length + words.length) / maxLines,\n                word = words.pop(),\n                line = [word],\n                joined,\n                lineNumber = 0,\n                lineHeight = 1.1, // ems\n                tspan = text.text(null).append(\"tspan\").text(word);\n\n            while (true) {\n                word = words.pop();\n                if (!word) break;\n                line.push(word);\n                joined = line.join(\" \");\n                tspan.text(joined);\n                if (joined.length > minChars && tspan.node().getComputedTextLength() > width) {\n                    line.pop();\n                    tspan.text(line.join(\" \"));\n                    line = [word];\n                    tspan = text.append(\"tspan\").text(word);\n                    lineNumber++;\n                }\n            }\n\n            var initial = 0.35 - lineNumber * lineHeight / 2,\n                x = text.attr(\"x\"),\n                y = text.attr(\"y\");\n\n            text.selectAll(\"tspan\")\n                .attr(\"x\", x)\n                .attr(\"y\", y)\n                .attr(\"dy\", function(d, i) {\n                     return (initial + i * lineHeight) + \"em\";\n                });\n        };\n    }\n\n    function circleMargin(current, interior, exterior) {\n        var margin = interior[0].radius - distance(interior[0], current), i, m;\n        for (i = 1; i < interior.length; ++i) {\n            m = interior[i].radius - distance(interior[i], current);\n            if (m <= margin) {\n                margin = m;\n            }\n        }\n\n        for (i = 0; i < exterior.length; ++i) {\n            m = distance(exterior[i], current) - exterior[i].radius;\n            if (m <= margin) {\n                margin = m;\n            }\n        }\n        return margin;\n    }\n\n    // compute the center of some circles by maximizing the margin of\n    // the center point relative to the circles (interior) after subtracting\n    // nearby circles (exterior)\n    function computeTextCentre(interior, exterior) {\n        // get an initial estimate by sampling around the interior circles\n        // and taking the point with the biggest margin\n        var points = [], i;\n        for (i = 0; i < interior.length; ++i) {\n            var c = interior[i];\n            points.push({x: c.x, y: c.y});\n            points.push({x: c.x + c.radius/2, y: c.y});\n            points.push({x: c.x - c.radius/2, y: c.y});\n            points.push({x: c.x, y: c.y + c.radius/2});\n            points.push({x: c.x, y: c.y - c.radius/2});\n        }\n        var initial = points[0], margin = circleMargin(points[0], interior, exterior);\n        for (i = 1; i < points.length; ++i) {\n            var m = circleMargin(points[i], interior, exterior);\n            if (m >= margin) {\n                initial = points[i];\n                margin = m;\n            }\n        }\n\n        // maximize the margin numerically\n        var solution = fmin(\n                    function(p) { return -1 * circleMargin({x: p[0], y: p[1]}, interior, exterior); },\n                    [initial.x, initial.y],\n                    {maxIterations:500, minErrorDelta:1e-10}).solution;\n        var ret = {x: solution[0], y: solution[1]};\n\n        // check solution, fallback as needed (happens if fully overlapped\n        // etc)\n        var valid = true;\n        for (i = 0; i < interior.length; ++i) {\n            if (distance(ret, interior[i]) > interior[i].radius) {\n                valid = false;\n                break;\n            }\n        }\n\n        for (i = 0; i < exterior.length; ++i) {\n            if (distance(ret, exterior[i]) < exterior[i].radius) {\n                valid = false;\n                break;\n            }\n        }\n\n        if (!valid) {\n            if (interior.length == 1) {\n                ret = {x: interior[0].x, y: interior[0].y};\n            } else {\n                var areaStats = {};\n                intersectionArea(interior, areaStats);\n\n                if (areaStats.arcs.length === 0) {\n                    ret = {'x': 0, 'y': -1000, disjoint:true};\n\n                } else if (areaStats.arcs.length == 1) {\n                    ret = {'x': areaStats.arcs[0].circle.x,\n                           'y': areaStats.arcs[0].circle.y};\n\n                } else if (exterior.length) {\n                    // try again without other circles\n                    ret = computeTextCentre(interior, []);\n\n                } else {\n                    // take average of all the points in the intersection\n                    // polygon. this should basically never happen\n                    // and has some issues:\n                    // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n                    ret = getCenter(areaStats.arcs.map(function (a) { return a.p1; }));\n                }\n            }\n        }\n\n        return ret;\n    }\n\n    // given a dictionary of {setid : circle}, returns\n    // a dictionary of setid to list of circles that completely overlap it\n    function getOverlappingCircles(circles) {\n        var ret = {}, circleids = [];\n        for (var circleid in circles) {\n            circleids.push(circleid);\n            ret[circleid] = [];\n        }\n        for (var i  = 0; i < circleids.length; i++) {\n            var a = circles[circleids[i]];\n            for (var j = i + 1; j < circleids.length; ++j) {\n                var b = circles[circleids[j]],\n                    d = distance(a, b);\n\n                if (d + b.radius <= a.radius + 1e-10) {\n                    ret[circleids[j]].push(circleids[i]);\n\n                } else if (d + a.radius <= b.radius + 1e-10) {\n                    ret[circleids[i]].push(circleids[j]);\n                }\n            }\n        }\n        return ret;\n    }\n\n    function computeTextCentres(circles, areas) {\n        var ret = {}, overlapped = getOverlappingCircles(circles);\n        for (var i = 0; i < areas.length; ++i) {\n            var area = areas[i].sets, areaids = {}, exclude = {};\n            for (var j = 0; j < area.length; ++j) {\n                areaids[area[j]] = true;\n                var overlaps = overlapped[area[j]];\n                // keep track of any circles that overlap this area,\n                // and don't consider for purposes of computing the text\n                // centre\n                for (var k = 0; k < overlaps.length; ++k) {\n                    exclude[overlaps[k]] = true;\n                }\n            }\n\n            var interior = [], exterior = [];\n            for (var setid in circles) {\n                if (setid in areaids) {\n                    interior.push(circles[setid]);\n                } else if (!(setid in exclude)) {\n                    exterior.push(circles[setid]);\n                }\n            }\n            var centre = computeTextCentre(interior, exterior);\n            ret[area] = centre;\n            if (centre.disjoint && (areas[i].size > 0)) {\n                console.log(\"WARNING: area \" + area + \" not represented on screen\");\n            }\n        }\n        return  ret;\n    }\n\n    // sorts all areas in the venn diagram, so that\n    // a particular area is on top (relativeTo) - and\n    // all other areas are so that the smallest areas are on top\n    function sortAreas(div, relativeTo) {\n\n        // figure out sets that are completly overlapped by relativeTo\n        var overlaps = getOverlappingCircles(div.selectAll(\"svg\").datum());\n        var exclude = {};\n        for (var i = 0; i < relativeTo.sets.length; ++i) {\n            var check = relativeTo.sets[i];\n            for (var setid in overlaps) {\n                var overlap = overlaps[setid];\n                for (var j = 0; j < overlap.length; ++j) {\n                    if (overlap[j] == check) {\n                        exclude[setid] = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // checks that all sets are in exclude;\n        function shouldExclude(sets) {\n            for (var i = 0; i < sets.length; ++i) {\n                if (!(sets[i] in exclude)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        // need to sort div's so that Z order is correct\n        div.selectAll(\"g\").sort(function (a, b) {\n            // highest order set intersections first\n            if (a.sets.length != b.sets.length) {\n                return a.sets.length - b.sets.length;\n            }\n\n            if (a == relativeTo) {\n                return shouldExclude(b.sets) ? -1 : 1;\n            }\n            if (b == relativeTo) {\n                return shouldExclude(a.sets) ? 1 : -1;\n            }\n\n            // finally by size\n            return b.size - a.size;\n        });\n    }\n\n    function circlePath(x, y, r) {\n        var ret = [];\n        ret.push(\"\\nM\", x, y);\n        ret.push(\"\\nm\", -r, 0);\n        ret.push(\"\\na\", r, r, 0, 1, 0, r *2, 0);\n        ret.push(\"\\na\", r, r, 0, 1, 0,-r *2, 0);\n        return ret.join(\" \");\n    }\n\n    // inverse of the circlePath function, returns a circle object from an svg path\n    function circleFromPath(path) {\n        var tokens = path.split(' ');\n        return {'x' : parseFloat(tokens[1]),\n                'y' : parseFloat(tokens[2]),\n                'radius' : -parseFloat(tokens[4])\n                };\n    }\n\n    /** returns a svg path of the intersection area of a bunch of circles */\n    function intersectionAreaPath(circles) {\n        var stats = {};\n        intersectionArea(circles, stats);\n        var arcs = stats.arcs;\n\n        if (arcs.length === 0) {\n            return \"M 0 0\";\n\n        } else if (arcs.length == 1) {\n            var circle = arcs[0].circle;\n            return circlePath(circle.x, circle.y, circle.radius);\n\n        } else {\n            // draw path around arcs\n            var ret = [\"\\nM\", arcs[0].p2.x, arcs[0].p2.y];\n            for (var i = 0; i < arcs.length; ++i) {\n                var arc = arcs[i], r = arc.circle.radius, wide = arc.width > r;\n                ret.push(\"\\nA\", r, r, 0, wide ? 1 : 0, 1,\n                         arc.p1.x, arc.p1.y);\n            }\n            return ret.join(\" \");\n        }\n    }\n\n    exports.fmin = fmin;\n    exports.minimizeConjugateGradient = minimizeConjugateGradient;\n    exports.bisect = bisect;\n    exports.intersectionArea = intersectionArea;\n    exports.circleCircleIntersection = circleCircleIntersection;\n    exports.circleOverlap = circleOverlap;\n    exports.circleArea = circleArea;\n    exports.distance = distance;\n    exports.circleIntegral = circleIntegral;\n    exports.venn = venn;\n    exports.greedyLayout = greedyLayout;\n    exports.scaleSolution = scaleSolution;\n    exports.normalizeSolution = normalizeSolution;\n    exports.bestInitialLayout = bestInitialLayout;\n    exports.lossFunction = lossFunction;\n    exports.disjointCluster = disjointCluster;\n    exports.distanceFromIntersectArea = distanceFromIntersectArea;\n    exports.VennDiagram = VennDiagram;\n    exports.wrapText = wrapText;\n    exports.computeTextCentres = computeTextCentres;\n    exports.computeTextCentre = computeTextCentre;\n    exports.sortAreas = sortAreas;\n    exports.circlePath = circlePath;\n    exports.circleFromPath = circleFromPath;\n    exports.intersectionAreaPath = intersectionAreaPath;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./static/repository/plugins/benfred/venn.js\n ** module id = 160\n ** module chunks = 20\n **/"],"sourceRoot":""}